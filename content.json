{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"","text":"个人简介 分享一句很喜欢的话： “萧伯纳曾说过：人生有两大悲剧一个是万念俱灰，一个是踌躇满志。“ 我最喜欢干的事情，就是在一个陌生的城市里游荡，既然是陌生的城市，也就无所谓迷路，因为走在哪里都是迷路。行人从自己身边匆匆路过，有人奔赴约会，有人回家做饭，有人急着去看电影……我只身一人，没啥目的，不赶时间，也不认识什么人，站天桥上看着车水马龙，微微一笑，我想上帝也经常干这个事儿吧？ 本站推荐索引 博主推荐的一些主题相关 使用jsDelivr加速github图床效果 使用Jekyll+gitee搭建自己的博客 使用阿里云和宝塔搭建wordpress个人博客 技术知识点 Java反射 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 计划2021计划： 2021.1.18 总结： 还没开始呢！走着瞧 2020计划 2019.12.31 总结： 这一年对大多数人都不太过好，包括我 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 总结： 有坚持又放弃大多数都是放弃了 时间轴记录","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"{\"class\":{\"class_name\":\"友情链接\",\"link_list\":{\"1\":{\"name\":\"xxx\",\"link\":\"https://baidu.com\",\"avatar\":\"https://cdn.xxxxx.top/avatar.png\",\"descr\":\"xxxxxxx\"},\"2\":{\"name\":\"xxxxxx\",\"link\":\"https://www.xxxxxxcn/\",\"avatar\":\"https://xxxxx/avatar.png\",\"descr\":\"xxxxxxx\"}}},\"class2\":{\"class_name\":\"链接无效\",\"link_list\":{\"1\":{\"name\":\"梦xxx\",\"link\":\"https://blog.xxx.com\",\"avatar\":\"https://xxxx/avatar.png\",\"descr\":\"xxxx\"},\"2\":{\"name\":\"xx\",\"link\":\"https://www.axxxx.cn/\",\"avatar\":\"https://x\",\"descr\":\"xx\"}}}}","link":"/data/link.json"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"在线工具","text":"以下都是使用过的比较好用的在线工具： 123","link":"/tools/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Amazing使用Gitalk","text":"人与人最好的关系，就是可以彼此不说话——云村边上的小卖部 早些天的时候换了个博客的主题名字：hexo-theme-amazing，就如现在看到的这样，和icarus是相像的因为只是作者在这个基础上面丰富了一些内容，所以我个人觉得还不错的就尝试了一下，主要也是为了好看来的，这个主题支持Gitalk这个评论系统，在这之前尝试过一些其他的评论系统，这也是一次学习。 一，学会百度或者谷老师很重要，在网上查了一些资料，也跟着搞通了。 先看看Gitlak的官网：https://gitalk.github.io/ 文档写的不是那么的详细，写了本地使用，以及React的使用方式，这些不用管，来到GITHUB我们先创建一个GitHub Application，或者在这里直接申请，注意了，这里官方说明了，除了需要一个Application，我们需要一个存储库，来存放我们的评论，如果没有的话，会出现Not found错误提示 二，申请步骤也很简单，按照下面的说明来就好了 这里的GitHub地址指的是你的博客地址别搞错了，如果你用的GitHub加上hexo搭建的博客，就把你的GitHub博客主页地址放上去就可以了，但是你用了第三方域名，比如说：http:lyqi.live，我们就要把这个域名地址放上去才可以 三，生成之后我们需要两个东西：Client ID和我们的Client secrets 1，复制 四，把这两个密钥复制到我们的主题配置文件里面去配置就好了 1，大致格式如下： 12345678910111213comment: type: gitalk language: zh-CN #zh-CN #Localization language key, en, zh-CN and zh-TW are currently available. enable: true owner: # 你的GitHub名字比如说：T1 repo: # 这是是前面说过需要创建一个存储库，这里就是那个存储库的名字，比如说：blog-comment client_id: # 这里也是我们刚刚复制我们的那一串 client id。比如说：123456 client_secret: # 这里也是我们刚刚复制我们的那一串 client secret。比如说：123456 admin: ['VIlboys'] # 这里也是 你的GitHub名字比如说：T1 create_issue_manually: true distraction_free_mode: false has_hot_recommend: true # 是否有热门推荐 has_latest_comment: true #是否有最新评论 2，接着我们上线试一试 123hexo cleanhexo s 如果你想在本地测试的时候请把你的Homepage URL和你的Authorization callback URL改成本地的地址，不然的话，是没法进行评论的 之后我们再部署到GitHub上面的时候我们，需要把Homepage URL和你的Authorization callback URL这两个参数改回来，如果是遇到未找到相关的 Issues 进行评论请联系 @xxx 初始化创建 这一类问题的时候其实只要初始化我们的 Issues ，检查admin这个参数是否写错了，然后使用自己的GitHub登录就好了 本文写自：2020-1-24——明天依旧美好","link":"/2021/01/24/Amazing%E4%BD%BF%E7%94%A8Gitalk/"},{"title":"Dockerfile定制镜像学习","text":"使用dockerfile来定制一个自己的镜像步骤：1），首先我们在/usr/local下新建一个Docker文件夹；执行命令; 1[root@localhost local]# mkdir docker 2），进入这个文件夹，创建一个myshop的目录（也可以是别的名字，或者是你的项目名字） 1[root@localhost docker]# mkdir myshop 3），再进入这个myshop的文件夹，创建一个配置文件 1[root@localhost myshop]# vi Dockerfile 4），在vim编辑写上以下内容； 123FROM tomcat:latest //继承tomcat的这个镜像COPY index.jsp /usr/local/tomcat/webapps/ROOT //把index.jsp覆盖到tomcat的ROOT目录下 5)，创建一个index.jsp 1hello world1 6），构建运行；silly_franklin(可以自起名字) .表示在当前项目找到名为dockerfile的配置文件 1[root@localhost myshop]# docker build -t silly_franklin . 7)，查看成果 8），然后我们可以使用命令 1[root@localhost myshop]# docker images 9），可以看到多了一个silly_franklin镜像 10），然后我们运行这个镜像(我的(宿主机)8080端口已经在测试了，所以这里使用的(宿主机)的端口是8010) 1[root@localhost myshop]# docker run -p 8010:8080 -d --name bjq -d silly_franklin 在浏览器查看: 这样就完成了自制镜像; 好运！","link":"/2019/10/29/Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F%E5%AD%A6%E4%B9%A0/"},{"title":"Linux","text":"学习CentOS linux的一些基础技能 先决条件: VMware CentOS6.5 Xshell Filezila 步骤:一，安装JDK1.81，把压缩包上传到服务器/usr/local/tmp这里目录下面（我这里是提前新建好的这里目录的文件夹）​ 使用Filezile软件上传文件 2，解压jdk压缩包(这个过程代码很多没截全图) #tar zxvf 你的jdk文件名 3，把解压后文件复制到/usr/local/jdk8 cp -r jdk1.8.0_221 /usr/local/jdk8 使用cd..向上级跳转 然后输入ls查看有没有成功 4，配置环境变量，执行命令 #vim /etc/profile 5，修改文件中内容 进入文件夹后按下i或者insert键既可修改 先把#export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL前面打上#注释掉 后面添加我们的配置 分隔符使用的是冒号:而不是分号； $变量名表示引用 export 添加或修改变量 1234#export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROLexport JAVA_HOME=/usr/local/jdk7export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 6，解析文件（或重启系统） #source /etc/profile 7，验证配置是否成功 #java -version 这里可以看到没有任何问题，显示了jdk版本号 8，可以编写一个小栗子测试 #vim Demo.java 写入以下代码 12345678public class Demo{public static void main(String[] args){System.out.println(&quot;hello Word&quot;);}} 按下ese结束输入然后按下：再输入wq保存并退出 运行命令: javac Demo.java 然后输入: java Demo 运行结果:没有问题 二，安装Tomcat1，把tomcat压缩包上传到服务器上 2，解压文件 tar zxvf apache-tomcat-8.5.45.tar.gz 3，解压后的文件夹复制到/usr/local/tomcat下 #cp -r apache-tomcat-8.5.45 ../tomcat 4，配置环境变量 #vim/etc/profile 添加以下内容 12export TOMCAT_HOME=/usr/local/tomcatexport CATALINA_HOME=/usr/local/tomcat 配置之后呢执行source /etc/profile，然后可以进入tomcat文件夹下试试运行 1./startup.sh 然后打开我们的本地浏览器看能不能；访问地址：是你的虚拟机上IP地址加上8080端口如下这样 1192.xx.xx.130:8080 你可能会看到访问不到这个tomcat的页面，刷新也不行；原因是因为虚拟机只放行22端口，其他的端口都被我们的防火墙给拦截了所以访问不到； 4.1解决的的办法：放行8080端口 进入到系统配置文件 1vim /etc/sysconfig/iptables 我们只需要在后面添加一句话这句话的意思是放行8080端口 如果想放行多个端口可以这样写:8080:9000 配置之后呢还需要重启一下服务才会生效，不然不起作用 进入到sysconfig文件 1#cd /etc/sysconfig 执行重启服务 1#service iptables restart 5，启动tomcat，进入到tomcat/bin文件 先执行命令：**./shutdown.sh**关闭tomcat 5.1 启动有两种启动方式 直接启动： ./startup.sh 123453. 启动并动态打印启动信息：4. ``` #./startup.sh &amp; tailf ../logs/catalina.out 查看页面: 三，安装mysql1，还是把文件上传 2，然后解压文件:1# tar zxvf 文件名 3，复制文件到/usr/local/mysql1#cp -r mysql-5.6.31-linux-glibc2.5-x86_64 ../mysql 4，创建用户组和用户(是不想把root付给mysql，如果你不考虑这些事情的话就不用这么创建)4.1添加用户组，命名为mysql 命令： 1groupadd mysql 4.2 创建用户MySQL，并指定所属群组为MySQL 命令： 1useradd -r -g mysql mysql 下面的命令必需要在/usr/local/mysql中执行（后面有一个点这点需要注意） 变更mysql用户组拥有操作当前文件夹的权限命令： 1chgrp -R mysql . 变更mysql用户具有操作本级目录的权限。 命令： 1chown -R mysql . 上面两个命令也可以换成下面一条命令 chown -R mysql:mysql ./ 5，判断/etc/my.cnf是否存在命令： 1ls /etc/my.cnf 如果存在就删除： 1rm /etc/my.cnf 初始化数据库 1./scripts/mysql_install_db --user=mysql 6，修改配置文件复制my.cnf文件： 1cp support-files/my-default.cnf /etc/my.cnf 复制启动文件:(最后的mysql是你的服务名,如果你想启动的话就必须得写 service mysql start) 1cp support-files/mysql.server /etc/rc.d/init.d/mysql 这个时候可以启动服务： 1service mysql start 会提示找不到这个命令，所以这里我们还得添加一个软连接；添加后得开启服务不然会报错(红色框框部分) 1ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql 开启服务后输入： 1mysql -u root -p 按回车不需要输入密码就进入了Mysql 7，修改mysql得密码和访问权限刚创建的root账户是没有密码的的，直接回车就可以进入为了修改访问权限我们修改一下root密码 我们得先进入mysql这个数据库内 1mysql&gt; use mysql; 你可以先看下user的描述我们修改的是password这一列 1mysql&gt; desc user; 然后执行命令： 1mysql&gt; update user set password=password(775741) where user='root'; 然后我们得刷新权限：（不然你得重启） 1mysql&gt; flush privileges; 接着退出mysql编辑： 然后在执行：(这个时候我们就有密码了) 1# mysql -u root -p 这个时候我们可以在本地windows上连接一下这个服务器的数据库;你会发现连接不上会报错 因为这个3306得端口号是没有放行得，user里面也没有授权% 我们可以执行以下命令权限赋予命令 1grant all privileges on *.* to root@'%' identified by '775741' with grant option; 可以查看有没有%接着刷新权限 再去放行端口3306： 1vim /etc/sysconfig/iptables 添加3306端口: 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT 再去本地上测试连接： 就可以看到能够连接上了 到此完整结束；参考资料: 百老师和谷老师 脑子","link":"/2019/09/17/CentOS%E5%AE%89%E8%A3%85JDK+Tomcat+mysql/"},{"title":"Docker如何安装Redis","text":"前提条件： 我们需要一台本地的虚拟机或者(云主机)都行 其次还需要一个能连接上linux系统的工具可以是cmd或者xshell或者是putty 然后去Docker官网找到redis镜像 地址： https://hub.docker.com/_/redis 1，使用命令把redis镜像pull下来 1docker pull redis 2，然后使用命令启用： 1docker run -d -p 6379:6379 --name myredis redis -d 表示后台运行 -p 暴露端口号 –name 给你的redis镜像取个名字 3，使用RedisDesktopManager工具连接测试；如下图所示 出现Successful connection to redis-server就成功了 然后这里推荐一个学习Redis命令的网站 链接： http://redisdoc.com/ 和 http://doc.redisfans.com/ 结束~~","link":"/2019/12/14/Docker%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Redis/"},{"title":"Redis集群搭建","text":"一，集群简介参考redis的参考手册的说明 redis官方网站 redis官方参考手册 Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 Redis 集群提供了以下两个好处： 将数据自动切分（split）到多个节点的能力。 当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。 3.0版本以后的redis集群架构图： 图片是参考https://www.jianshu.com/p/887c6b84a5a7这篇博客 先决条件: redis3.0.0单机版 xshell官网 以及一个CentOS6.5的一个linux虚拟机 二，创建使用redis集群 1，集群和伪集群 ​ 1.1集群：每个业务单元都安装到单独的服务器上 ​ 1.2伪集群：所有业务单元都安装到同一个服务器上，通过端口区分不同的业务单元. 2，步骤 1，我们得先把redis-3.0.0.gem这个文件上传到linux服务上 1，安装需要用到的ruby脚本 1# yum install ruby -y 2，安装ruby包管理器 1# yum install rubygems -y 3，脚本需要ruby其他包，所以安装这个redis.gem(这里一定把redis-3.0.0.gem这个文件上传后在tmp目录下运行下面得命令) 1#gem install redis-3.0.0.gem 4，在/usr/local/下新建一个redis-cluster文件夹 1#mkdir redis-cluster 5，把之前安装好的redis/bin复制到redis-cluster中并起名为redis01（可以为其他,比如7001） 1# cp -r bin ../redis-cluster/redis01 6，删除掉redis01中的dump.rdb数据库文件(相当于还原整个数据文件,下一次运行还是会产生这个文件) 1# rm -rf dump.rdb 7，运行 1# vim redis.conf 修改redis01中的的端口号，找到port然后修改后面的端口号为7001 去掉cluster-enabled yes 前面的注释（默认是注释的我们去掉注释就ok） 如果之前设置过密码,注释掉密码.如果没有设置过就忽略 这步骤 8，把redis01 文件夹在复制5 份,分别起名为redis02,redis03,redis04,redis05,redis06此命令需要在redis-cluster 目录下执行 12345cp -r redis01 redis02cp -r redis01 redis03cp -r redis01 redis04cp -r redis01 redis05cp -r redis01 redis06 9，此命令需要在redis-cluster 目录下执行 1# vim redis02/redis.conf 1把其他5 个文件夹中redis.conf 中port 修改成不同的值, 分别为7002,7003,7004,7005,7006（如下图所示） 7002 7003 依次执行7004,7005,7006 10，然后我们回到redis的解压目录去redis 解压目录中src 下执行此命令 ​ 10.1目的就是把redis-trib.rb复制到redis-cluster中. 1# cp *.rb /usr/local/redis-cluster/ 11，创建一个批量启动文件；执行命令 1# vim startal.sh 11.1把下面的内容粘贴到文件中 123456789101112131415161718cd redis01./redis-server redis.confcd ..cd redis02./redis-server redis.confcd ..cd redis03./redis-server redis.confcd ..cd redis04./redis-server redis.confcd ..cd redis05./redis-server redis.confcd ..cd redis06./redis-server redis.confcd .. 11.2这个时候创建这个文件后是不会立马生效的因为还没有执行的权限（你可以看到文件是灰色的）；所以我们给这个文件赋予权限 1# chmod +x startall.sh 12，执行脚本，启动所有redis服务 1# ./startall.sh 13，查看所有服务是否启动成功 1# ps aux | grep redis 15， 15.1：我们这个时候可以使用ruby语句来创建集群了 123./redis-trib.rb create --replicas 1 192.168.199.142:7001 192.168.199.142:7002 192.168.199.142:7003 192.168.199.142:7004 192.168.199.142:7005 192.168.199.142:7006 15.2：中间会提示你是否执行选项有yes和no输入yes即可 15.3：执行完成后我们就可以进行任意一个节点来测试了；执行命令 1# ./redis01/redis-cli -h 192.168.199.142 -p 7001 -c 15.4：如果不用了想关闭其中一个redis；执行命令 1# redis01/redis-cli -p 7001 shutdown 这样就算是差不多了 最后贴上一个java代码的测试 123456789101112131415161718@Test public void testjiqu() { Set&lt;HostAndPort&gt; set = new HashSet&lt;HostAndPort&gt;(); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7001)); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7002)); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7003)); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7004)); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7005)); set.add(new HostAndPort(&quot;192.168.199.142&quot;, 7006)); //使用集群使用JedisCluster这个类 JedisCluster jedisCluster = new JedisCluster(set); String age=jedisCluster.get(&quot;age&quot;); System.out.println(age); } 参考资料： 来自redis中文手册 以及百度和谷歌 以及相关博客 封面图片来自必应搜索","link":"/2019/10/06/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"Redis的安装和基本使用","text":"使用redis的好处很多；也是当前比较流行的Nosql数据库； 来自官网的说明: Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流的地理空间索引。Redis具有内置的复制，Lua脚本，LRU逐出，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。 先决条件： Redis3.0.0（这里是各个版本的下载连接） FileZilla Xshell 还有虚拟机CentOS6 步骤 1，把压缩包上传到linux 服务器上：示例位置: /usr/local/tmp/ 下 2，解压文件，打开Xshell连接虚拟机服务器，执行命令:1[root@bogon tmp]# tar zxvf redis-3.0.0.tar.gz 3，安装编译之前得先去安装gcc；执行命令：1[root@bogon tmp]# yum install gcc-c++ -y 截图不全只截图了一部分 3.1 安装完成后；cd redis-3.0.0 文件夹；执行命令 1[root@bogon tmp]# cd redis-3.0.0 3.2 然后再输入makr进行编译 1[root@bogon redis-3.0.0]# make 3.3 编译过程:(截图不全) 3.4 然后返回上一级 1cd .. 3.5 输入： 1ls 3.6 可以看到多了一个redis的文件夹 3.7 进入到这个文件夹下面 1[root@bogon local]# cd redis 3.8 查看 1[root@bogon redis]# ls 3.9 下面只有一个文件夹:bin 3.3.1 然后进入这个文件夹下面 1[root@bogon redis]# cd bin 3.3.2 查看: 1[root@bogon bin]# ls 3.3.3 这里可以看到有很多的命令。 redis-cli这个是redis自带的客户端工具 redis-server是启动redis命令 3.3.4 可以通过： ./redis-server来启动redis 1[root@bogon bin]# ./redis-server 3.3.5 可以看到一个类似数据库运用算法的图形 3.3.6 这个时候会有一点小问题,启动了之后你的光标会动不了，这个时候我们可以使用*ctrl+c中断,但是你中断以后redis也会跟着和你说byebye了； 3.3.7 这个时候我们需要把daemonize 由no 修改成yes,守护进程启动;执行命令 1[root@bogon redis-3.0.0]# cp redis.conf /usr/local/redis/bin 3.3.8 修改；执行命令； 1[root@bogon redis-3.0.0]# vim redis.conf 3.3.9 找到下面这句话默认是no改成yes就ok了； 3.4.1 这个时候启动命令后面得加上：redis.conf 1[root@bogon bin]# ./redis-server redis.conf 3.4.2 可以使用：# ps aux|grep redis查看端口号(默认6379) 1[root@bogon bin]# ps aux|grep redis 如果想执行关闭redis服务；执行命令: [root@bogon bin]# ./redis-cli shutdown 4，测试可行否; 4.1使用自带得客户端工具 1[root@bogon bin]# ./redis-cli 会进入到客户端的当前本机127.0.0.1:6379地址 基本的增删操作都可以使用 ps: redis默认的是没有密码的如果想修改密码就修改./redis.conf里面的requirepass 后面写上你的密码即可 5，Redis常用命令 ​ -h 表示主机ip ​ -p 表示端口 ​ -a 表示密码 5.1 如果想要连接别人的电脑和端口就这么写： 1./redis-cli -h 192.xx.xx.xx -p 6379 -a 密码 使用Redis在windows下的客户端工具：RedisDesktopManager 连接成功： 前提是在你启动redis的情况下不然会连接不上报错 查看 到此结束，谢谢; 参考资料: Redis官网 命令大全 以及谷老师 封面图来自:酷图","link":"/2019/09/23/Redis%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Maven新建Web项目","text":"简单记录一下最近学习Maven的一个基础:新建Maven项目​ 这里IDE用的是(Eclipse)​ 打开点击File—&gt;New—&gt;Maven Project​ (如下图)点Next​ 输入web选择下面出现的点击Next​ ​ Group Id:输入的是你的包名类似java包下的包 ​ Artiface Id:输入你的项目名:是整个项目唯一的标识符;点击 Finish 如下图所示​ 注意 项目创建后在index.jsp会报这个错误:The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path ​ ​ 解决的办法：右键项目选择–&gt;Build Path—&gt;Configure Build Path​ 选择Add Library​ ​ 选择Server Runtime 点击Next​ ​ 选择你的Tomcat服务器我这里用的是8.5的然后点击Finish就不会报错了​ 到此第一的MavenWeb项目就完成了","link":"/2021/01/17/Maven%E6%96%B0%E5%BB%BAWeb%E9%A1%B9%E7%9B%AE/"},{"title":"Servlet回顾","text":"JSP就是servlet只不过是另外一种表现形式 Servlet生命周期","link":"/2019/12/11/Servlet%E5%9B%9E%E9%A1%BE/"},{"title":"SprinBoot简单的CRUD操作","text":"关于SpringBoot一个简单的CRUD的实现;SpringBoot是什么？：官方网站（总之这东西挺好用） 先决条件： eclipse2019 JDK1.8 springBoot 实际操作 1，新建Maven项目​ 项目目录结构 1.1修改Pom.xml文件 使用的SpringBoot版本是：1.5.10 使用的视图层技术是：thymeleaf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.bjq&lt;/groupId&gt; &lt;artifactId&gt;12-spring-boot-springmvc-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 修改JDK版本和Thymeleaf版本 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;t hymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2，编写application.properties全局配置文件在src/main/resources文件下新建一个application.properties 12345678spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.bjq.pojo 1.3，数据库表设计123456789101112--建立数据库DROP DATABASE IF EXISTS ssm;CREATE DATABASE ssm DEFAULT CHARACTER SET utf8;USE ssm;--建立表DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `age` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; 2，添加用户 添加实体类 1234567891011121314151617181920212223242526package com.bjq.pojo;public class Users { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 创建Mapper接口和配置文件 12345678910111213141516171819202122232425262728293031323334package com.bjq.mapper;import java.util.List;import com.bjq.pojo.Users;public interface UsersMapper { /* * 添加方法 * */ void insertUser(Users users); /* * 查询所有方法 * */ List&lt;Users&gt; selectUsersAll(); /** * 数据回显 * */ Users selectUserById(int id); /** * 数据修改 * */ int updateUser(Users users); /** * 删除用户 * */ int deleteUser(int id);} Mapper配置文件 (id=insertUser和Mapper接口对应的方法名要一样的) 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bjq.mapper.UsersMapper&quot;&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;users&quot;&gt; insert into users(name,age) values(#{name},#{age}) &lt;/insert&gt; &lt;select id=&quot;selectUsersAll&quot; resultType=&quot;users&quot;&gt; select * from users &lt;/select&gt; &lt;select id=&quot;selectUserById&quot; resultType=&quot;users&quot;&gt; select * from users where id = #{value} &lt;/select&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;users&quot;&gt; update users set name=#{name},age=#{age} where id=#{id} &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from users where id=#{id} &lt;/delete&gt; &lt;/mapper&gt; 创建Service接口和实现类（业务层） 1234567891011121314151617181920212223242526272829303132333435package com.bjq.service;import java.util.List;import com.bjq.pojo.Users;public interface UsersService { /* * 添加方法 * */ void addUser(Users users); /* * 查询方法 * */ List&lt;Users&gt; findUserAll(); /** * 数据回显 * */ Users selectUserById(int id); /** * 数据修改 * */ int updateUser(Users users); /** * 删除用户 * */ int deleteUser(int id); } 实现类（业务层） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bjq.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.bjq.mapper.UsersMapper;import com.bjq.pojo.Users;import com.bjq.service.*;@Service@Transactionalpublic class UsersServiceImpl implements UsersService { @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) { this.usersMapper.insertUser(users); } @Override public List&lt;Users&gt; findUserAll() { return this.usersMapper.selectUsersAll(); } @Override public Users selectUserById(int id) { return this.usersMapper.selectUserById(id); } @Override public int updateUser(Users users) { return this.usersMapper.updateUser(users); } @Override public int deleteUser(int id) { return this.usersMapper.deleteUser(id); } } 实现Controller 创建的showPage方法是为了方便我们找到相应的页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.bjq.controller;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import com.bjq.pojo.Users;import com.bjq.service.UsersService;@Controller@RequestMapping(&quot;/users&quot;)public class UsersController { @Autowired private UsersService usersService; /** * 页面跳转 */ @RequestMapping(&quot;/{page}&quot;) public String showPage(@PathVariable String page){ return page; } /** * 添加用户 */ @RequestMapping(&quot;/addUser&quot;) public String addUser(Users users){ this.usersService.addUser(users); return &quot;ok&quot;; } /** * 查询所有用户 * */ @RequestMapping(&quot;/getAll&quot;) public String getAll(Model model) { List&lt;Users&gt; list = this.usersService.findUserAll(); model.addAttribute(&quot;list&quot;, list); return &quot;getAll&quot;; } /** * 根据ID查询用户 * */ @RequestMapping(&quot;/findUserById&quot;) public String findUserById(Integer id,Model model) { Users user = this.usersService.selectUserById(id); model.addAttribute(&quot;user&quot;, user); return &quot;updateUser&quot;; } /** * 根据ID修改用户 * */ @RequestMapping(&quot;/editUser&quot;) public String updateUser(Users users) { this.usersService.updateUser(users); return &quot;ok&quot;; } /** * 删除信息 * */ @RequestMapping(&quot;/deleteUserById&quot;) public String deleteUserById(Integer id) { this.usersService.deleteUser(id); return &quot;ok&quot;; } } 实现HTML页面 添加页面：在**src/main/resources目录下创建一个文件夹名字叫做:templates**在这个文件夹下面添加一个前端页面(index.html)添加页面 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;添加数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action=&quot;@{/users/addUser}&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 数据查询页面[getAll.html] 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;显示数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;50%&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Age&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;td&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=&quot;u: ${list}&quot;&gt; &lt;td th:text=&quot;${u.id}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${u.name}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${u.age}&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;a th:href=&quot;@{/users/findUserById(id=${u.id})}&quot;&gt;更新操作&lt;/td&gt; &lt;td&gt;&lt;a th:href=&quot;@{/users/deleteUserById(id=${u.id})}&quot;&gt;删除操作&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 数据修改页面[updateUser.html] 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;数据显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action=&quot;@{/users/editUser}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:field=&quot;${user.id}&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot; th:field=&quot;${user.name}&quot; /&gt;&lt;br/&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; th:field=&quot;${user.age}&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;修改&quot;/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 处理成功页面[ok.html] 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;操作成功!&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 编写启动类(APP.java)需要注意的是我这里默认的端口：8080被占用了所以实现了EmbeddedServletContainerCustomizer的customize方法更改了端口号（如果你的没有被占用就无需实现这个接口） 使用的注释的部分也同样需要注意 12345678910111213141516171819202122package com.bjq;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;@SpringBootApplication@MapperScan(&quot;com.bjq.mapper&quot;) //@MapperScan 用户扫描MyBatis的Mapper接口public class App implements EmbeddedServletContainerCustomizer { public static void main(String[] args) { SpringApplication.run(App.class, args); } @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8005); }} 2.1，测试 添加页面 数据查询页面 数据修改页面 成功页面 参考资料: 万能的度娘和谷老师 以及不太行的脑子 封面图片来自：真棒壁纸","link":"/2019/09/09/SprinBoot%E7%AE%80%E5%8D%95%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/"},{"title":"Spring2.5.6和Hibernate3以及struts2整合(老框架)","text":"整合过程需要用到JDK1.7","link":"/2019/07/27/Spring2-5-6%E5%AD%A6%E4%B9%A0/"},{"title":"SpringBoot数据访问整合Druid连接池","text":"Druid相比Hikaricp的性能可能是要慢一些，但是Durid有自己的一套体系包括（监控，安全）等功能… Druid仓库地址：https://mvnrepository.com/artifact/com.alibaba/druid Hikaricp的官方地址： https://github.com/brettwooldridge/HikariCP 整合Druid前提呢：示例中使用的2.1.9版本得导入lo4j的相关依赖不然后面演示中会报错 错误信息 1234567891011121314151617***************************APPLICATION FAILED TO START***************************Description:Failed to bind properties under 'spring.datasource' to javax.sql.DataSource: Property: spring.datasource.filters Value: stat,wall,log4j Origin: class path resource [application.yml]:21:14 Reason: org.apache.log4j.PriorityAction:Update your application's configuration 导入log4j的依赖包， 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 步骤1），导入maven的相关依赖（版本1.1.8） 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt;&lt;/dependency&gt; 2），在application.properties的配置文件中配置相关配置 1234567spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.xx.xx:3307/jdbc driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource //配置druid的数据源 3），在test方法里面测试是否切换成功 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class SprintBoot06DataJdbcApplicationTests { @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); }} 查看控制台 Druid的数据源的其他配置123456789101112131415161718192021222324spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.1.7:3307/jdbc driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置这些之后并不一定就可以使用我们的这些配置的属性;我们需要编写一个类来绑定这些属性 12345678910@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)//以spring.datasource为前缀的所有属性全部绑定进来 @Bean public DataSource druid() { return new DruidDataSource(); }} 配置Druid的监控1)，配置一个管理后台的servlet 123456789101112131415161718192021222324252627282930313233@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid() { return new DruidDataSource(); } //配置Druid的监控 //1，配置一个管理后台的servlet @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String,Object&gt; iniParams = new HashMap&lt;&gt;(); //一些初始化参数 //用户和密码 iniParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); iniParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); //允许所有访问 iniParams.put(&quot;allow&quot;,&quot;&quot;); //拒绝192.168.43.78这个地址来访问 iniParams.put(&quot;deny&quot;,&quot;192.168.43.78&quot;); bean.setInitParameters(iniParams); return bean; }} 2)，配置一个web监控的filter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import javax.xml.crypto.Data;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid() { return new DruidDataSource(); } //配置Druid的监控 //1，配置一个管理后台的servlet @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String,Object&gt; iniParams = new HashMap&lt;&gt;(); iniParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); iniParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); iniParams.put(&quot;allow&quot;,&quot;&quot;); iniParams.put(&quot;deny&quot;,&quot;192.168.1.7&quot;); bean.setInitParameters(iniParams); return bean; } // 2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); Map&lt;String,Object&gt; iniParams = new HashMap&lt;&gt;(); bean.setFilter(new WebStatFilter()); //不拦截那些请求 iniParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(iniParams); //拦截所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; }} 配置完这些之后启动springboot应用； 访问地址 http://localhost:8001/druid/ 就可以看到druid的登陆页面账号admin和密码都是我们之前设置过的123456 登陆进来可以看到首页 到此结束; 参考资料： https://mvnrepository.com/artifact/com.alibaba/druid https://github.com/brettwooldridge/HikariCP","link":"/2019/11/07/SpringBoot%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%95%B4%E5%90%88Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"title":"SpringBoot的分布式dubbo+zookeeper","text":"1，Dubbo是什么?dubbo也是个服务框架，如果没有分布式的需求，可能用处不大，在分散的时候才有dubbo这样的架构的需求，其实是一个远程服务调用的分布式框架(告别web service模式中的wsdl，以服务者与消费者的方式在dubbo上注册） 这里还有一份来自官网的说明背景:dubbo 官网: http://dubbo.apache.org/zh-cn/ dubbo的流程图:（来自官网） 1.1docker原理。示例版本springboot是1.5.12，其他版本可能不兼容或者其他问题 2，zookeeper安装Zookeeper 1234#拉取zookeeper镜像docker pull zookeeper:3.4.11#运行zookeeperdocker run --name zk01 -p 2181:2181 --restart always -d 56d414270ae3 3，Dubbo，Zookeeper整合实现效果：从服务消费者从注册中心调用服务生产者 1），引入dubbo和zkclient的相关依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 2)，配置service服务接口(TickickeretService)和实现类(TicketServiceImpl) 12345678910/** * Created by liu on */public interface TicketService { public String getTicket();} 实现类(TicketServiceImpl) 1234567891011121314import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;/** * Created by liu on */@Component@Servicepublic class TicketServiceImpl implements TicketService { @Override public String getTicket() { return &quot;《厉害了,我的哥》&quot;; }} 4），配置文件application.properties 1234567891011#配置当前应用的名字dubbo.application.name=provider-ticker#配置zookeeper地址，这里的zookeeper是在虚拟机中docker装的dubbo.registry.address=zookeeper://192.168.x.xx:2181#配置扫描的包,内容是要扫描的包的Reference(包的全类名)dubbo.scan.base-packages=com.bjq.ticker.service#这个就不多说了server.port=8010 5)，启动服务作为提供者 2，实现服务消费者1），同样导入duboo和zkclient相关依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 2），新建一个service.UserService,并将TickickeretService复制过来 【全类名相同-包相同】 使用 @Reference不要调用jdk包下提供的 @Reference,我们使用的时dubbo包下提供的 1234567891011121314import com.bjq.ticker.service.TicketService;import org.springframework.stereotype.Service;import com.alibaba.dubbo.config.annotation.Reference;@Servicepublic class UserService { @Reference TicketService ticketService; public void hello(){ String ticket = ticketService.getTicket(); System.out.printf(&quot;买到了&quot;+ticket); }} 3），配置文件 123dubbo.application.name=consumer-userdubbo.registry.address=zookeeper://192.168.43.78:2181 4)，编写一个测试类 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class ConsumerUserApplicationTests { //把UserService注入进来 @Autowired UserService userService; @Test public void contextLoads() { userService.hello(); }} 测试运行(前提是服务提供者一直在运行状态)：","link":"/2019/10/25/SpringBoot%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8Fdubbo-zookeeper/"},{"title":"SpringBoot之使用Thyemleaf基础篇","text":"Thymeleaf是什么?;官方翻译过来原话是:Thymeleaf是一个适用于Web和独立环境的现代服务器端Java模板引擎。可以在浏览器中正确显示HTML，也可以用作静态原型;Thymeleaf官网 先决条件: eclipse2019 springBoot 1，新建一个Maven项目 项目目录结构 2，编写Controller123456789101112131415161718package com.bjq.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ThymeleafController { @RequestMapping(&quot;show&quot;) public String thymeleaf(Model model){ //返回前台数据 model.addAttribute(&quot;msg&quot;, &quot;Thymeleaf的第一个小程序&quot;); return &quot;index&quot;; } } 3，在src/main/resource目录下面新建一个templates文件夹如下图所示: 4，新建index.html页面 代码如下: 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Thyemleaf显示数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text=&quot;Hello&quot;&gt;&lt;/span&gt; &lt;hr/&gt; &lt;span th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 5，编写启动类12345678910111213141516171819package com.bjq;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;@SpringBootApplicationpublic class App implements EmbeddedServletContainerCustomizer { public static void main(String[] args) { SpringApplication.run(App.class, args); } @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8003);//改变默认端口号 }} 6，测试程序 可以看到页面显示正常 ps:会有以下出错情况：原因是因为Thymeleaf3.0以前对HTML的语法非常的严谨,如果漏写了一个就会发生以下错误 解决的方式: 补全html语法的格式就是了 我们可以修改pom.xml文件，把thymeleaf版本修改为3x以上版本 1234567891011121314151617181920212223242526272829303132333435&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.bjq&lt;/groupId&gt; &lt;artifactId&gt;10-spring-boot-view-thymeleaf&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 修改JDK版本 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&gt;&gt;&gt;修改thymeleaf版本为3.0.2.RELEASE &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;&gt;&gt;&gt;修改thymeleaf-layout-dialect.version版本为2.0.4 &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 如果出错了以上方式都可以解决 参考资料: 来自万能的度娘和谷老师 来自不太聪明的脑子","link":"/2019/09/06/SpringBoot%E4%B9%8B%E4%BD%BF%E7%94%A8Thyemleaf%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"Springboot安全之SpringSecurity","text":"市面上比较热门的两个热门安全框架，Shiro以及SpringSecurity刚好学习了SrpingSecurity；做个总结记录 整合实现步骤:1)，导入导入SpringSecurity相关配置jar1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2），编写一个SpringSecurity的配置类123456789101112131415import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { //WebMvcConfigurerAdapter http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);} 一个入坑问题 继承了WebMvcConfigurerAdapter这个类然后IDEA给我报这个类以及过时了，去网上查了一下这个类在5.0已经过时了，可以去实现WebMvcConfigurer或者是继承WebMvcConfigurationSupport 这里还没发现根本不是继承这个类；然后我实现了WebMvcConfigurer这个类，启动的时候控制输出了这句话 1232019-10-23 14:30:21.952 INFO 6012 --- [ main] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: fdcb79a2-9d84-4d5c-b3b0-c8a7bcd7ce9c//这个是随机的不是唯一的 在访问页面的时候会提示要求你登陆，我在UserDetailsServiceAutoConfiguration这个类下面查看到在SecurityProperties这个类下管理登陆的用户名和密码; 默认的用户名:user 密码就是控制台输出的那串动态密码; 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static class User { /** * Default user name. */ private String name = &quot;user&quot;; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); /** * Granted roles for the default user name. */ private List&lt;String&gt; roles = new ArrayList&lt;&gt;(); private boolean passwordGenerated = true; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public String getPassword() { return this.password; } public void setPassword(String password) { if (!StringUtils.hasLength(password)) { return; } this.passwordGenerated = false; this.password = password; } public List&lt;String&gt; getRoles() { return this.roles; } public void setRoles(List&lt;String&gt; roles) { this.roles = new ArrayList&lt;&gt;(roles); } public boolean isPasswordGenerated() { return this.passwordGenerated; } } 如果想改这个用户和密码的话在application.properties文件里面写上 12spring.security.user.name=adminspring.security.user.password=admin 还说如果想关闭这个服务的话， 12# security 使能spring.security.basic.enabled = false 但是并不能关闭，只有修改用户名和密码； 这并不是我们想要的效果，我们自己的授权规则肯本没起作用。然后又回去查了一下代码发现了根本不是实现``WebMvcConfigurer或者继承WebMvcConfigurationSupport &lt;font color=&quot;red&quot;&gt;我们要继承的是&lt;/font&gt;WebSecurityConfigurerAdapter` 再次启动访问页面地址http://127.0.0.1:8001就不会提示你登陆,虽然还有可能输出那一串动态密码，但是我们自己的写的授权规则已经生效了; 3），控制请求的访问权限12345678910111213141516171819202122232425262728293031323334353637383940import org.springframework.boot.autoconfigure.security.servlet.WebSecurityEnablerConfiguration;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { //WebMvcConfigurerAdapter //定义授权规则 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;); //开启自动配置得登陆功能,效果,如果没有登陆权限就会来到登陆页面 http.formLogin(); //1,/login来到登陆页面 //2,重定向到login?error表示登陆失败 } //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .inMemoryAuthentication() .passwordEncoder(new MyPasswordEncoder()).withUser(&quot;root&quot;).password(&quot;root&quot;).roles(&quot;VIP1&quot;,&quot;VIP2&quot;).and() .withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;VIP2&quot;,&quot;VIP3&quot;) .and() .withUser(&quot;sum&quot;).password(&quot;sum&quot;).roles(&quot;VIP1&quot;,&quot;VIP3&quot;); }} 在第一个configure的方法里面表示在/这个请求下来到首页也就是所有人都可以访问，.antMatchers表示在/level1下的所有内容，只有vip1，能够访问； 第二个configure方法里面定义认证规则，.inMemoryAuthentication在内存里面查询用户，如果像用jdbc的也可以使用.jdbcAuthentication()相关配置 withUser设置的是用户名; password设置的是密码； roles给的角色是什么; and表示连接后面的 需要注意的是在.passwordEncoder里面new了一个我们自己的类MyPasswordEncoder，如果不new这个类的话会报以下的错误; 1java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot; 报错原因: 这是因为Spring boot 2.0.3引用的security 依赖是 spring security 5.X版本，此版本需要提供一个PasswordEncorder的实例，否则后台汇报错误。 解决方式: 创建一个类MyPasswordEncoder 实现PasswordEncoder接口 12345678910111213import org.springframework.security.crypto.password.PasswordEncoder;public class MyPasswordEncoder implements PasswordEncoder { @Override public String encode(CharSequence charSequence) { return charSequence.toString(); } @Override public boolean matches(CharSequence charSequence, String s) { return s.equals(charSequence.toString()); }} 这里参考了 https://www.cnblogs.com/wangxiayun/p/10304419.html 这篇博客 4)，注销和权限控制管理开启注销功能： 1http.logout().logoutSuccessUrl(&quot;/&quot;); 默认注销成功会返回/login?logout页面 我们可以改变返回url的路径地址使用.logoutSuccessUrl(&quot;/&quot;) /表示去主页 1234567891011121314151617181920212223@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { //WebMvcConfigurerAdapter @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;); //开启自动配置得登陆功能,效果,如果没有登陆权限就会来到登陆页面 http.formLogin(); //1,/login来到登陆页面 //2,重定向到login?error表示登陆失败 //开启自动配置的注销功能 http.logout().logoutSuccessUrl(&quot;/&quot;); //1,访问/logout表示用户退出,清空session //2,注销成功会返回/login?logout页面 //我们可以改变它的url地址使用.logoutSuccessUrl(&quot;/&quot;)来到首页 }} 5)，权限管理123456789101112&lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div align=&quot;center&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;!--获取到所有的角色--&gt; &lt;h2&gt;&lt;span style=&quot;color:red&quot; sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;，您好,您的会员等级是，&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注销&quot;&gt; &lt;/form&gt;&lt;/div&gt; 我们可以在页面中判断是否是认证了 通过sec:authorize判断是否经过认证如果没有授权就显示游客您好这段话，认证成功就会显示xxx您好那段话 sec:authentication=&quot;name&quot;：获取用户认证的名字； &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;：获取用户所有的角色 6)，根据不同的角色来显示不同的武功秘籍sec:authorize=&quot;hasRole('VIP1')&quot;：如果是VIP1就显示普通武功秘籍,后面是VIP2就显示高级武功秘籍等… 123456789101112131415161718192021222324&lt;div sec:authorize=&quot;hasRole('VIP1')&quot;&gt;&lt;h3&gt;普通武功秘籍&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;dvi sec:authorize=&quot;hasRole('VIP2')&quot;&gt;&lt;h3&gt;高级武功秘籍&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/dvi&gt;&lt;div sec:authorize=&quot;hasRole('VIP3')&quot;&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如果上面这些标签都没有起作用的话，请尝试降低Springboot版本,尝试过2.1.9版本是不会起作用的，换成2.0.2版本就可以正常使用了 参考了:https://blog.csdn.net/qq_37638061/article/details/87390678 这篇博客 开启记住我的功能1234//开启记住我功能 http.rememberMe(); //登陆成功以后，将cookie发给浏览器保存,以后访问页面带上这个cookie,只要通过检查就可以免登录默认有14天的保存时间 //点击注销会删除cookie 上面的登陆页面都是springboot默认的登陆页面，可以换成我们自己的登陆页面使用.loginPage(&quot;/userlogin&quot;)来到我们自己的登陆页面; .usernameParameter(&quot;user&quot;)带上我们的用户名; .passwordParameter(&quot;pwd&quot;)带上我们的密码; 1234567891011121314151617181920212223242526272829303132@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { //WebMvcConfigurerAdapter @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;); //开启自动配置得登陆功能,效果,如果没有登陆权限就会来到登陆页面 http.formLogin().usernameParameter(&quot;user&quot;).passwordParameter(&quot;pwd&quot;).loginPage(&quot;/userlogin&quot;); //1,/login来到登陆页面 //2,重定向到login?error表示登陆失败 //3,更多详细规定 //4,默认post形式的/login代表处理登陆 //5,一但定制loginPage；那么loginPage的post的请求就是登陆 //开启自动配置的注销功能 http.logout().logoutSuccessUrl(&quot;/&quot;); //1,访问/logout表示用户退出,清空session //2,注销成功会返回/login?logout页面 //我们可以改变它的url地址使用.logoutSuccessUrl(&quot;/&quot;)来到首页 //开启记住我功能 http.rememberMe().rememberMeParameter(&quot;remember&quot;); //登陆成功以后，将cookie发给浏览器保存,以后访问页面带上这个cookie,只要通过检查就可以免登录默认有14天的保存时间 //点击注销会删除cookie }} 我们在我们的登录页把记住我功能换成我们自己的1234//开启记住我功能http.rememberMe().rememberMeParameter(&quot;remember&quot;);//登陆成功以后，将cookie发给浏览器保存,以后访问页面带上这个cookie,只要通过检查就可以免登录默认有14天的保存时间//点击注销会删除cookie 登陆页面123456789101112&lt;body&gt; &lt;h1 align=&quot;center&quot;&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt; &lt;hr&gt; &lt;div align=&quot;center&quot;&gt; &lt;form th:action=&quot;@{/userlogin}&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;user&quot;/&gt;&lt;br&gt; &lt;!--name写上我们指定的用户名user--&gt; 密码:&lt;input name=&quot;pwd&quot;&gt;&lt;br/&gt; &lt;!--name写上我们指定的密码pwd--&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt;记住我&lt;br&gt;&lt;!--写上指定remember即可--&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt; 代码提取码：alh2","link":"/2019/10/23/Springboot%E5%AE%89%E5%85%A8%E4%B9%8BSpringSecurity/"},{"title":"Ubuntu18.4修改IP地址和网关","text":"前言：有时间多给自己补补课 一，查看各项信息，IP，网关1.查看IP:ifconfig 或者 ip a 可以看到你的网卡的信息，我这里是end33可能网卡显示也有不同 2.查看网关：netstat -rn 或者 route -n(要记得这个ip地址) 二、修改IP、网关我们首先以root用户登陆，因为普通用户登陆是没有修改写入删除的权限的，所以我们可以先使用命令： 1sudo passwd root 然后输入你的密码，再接着输入你的root用户的密码即可 然后输入su切换root用户登陆 1.修改Ip，网关使用命令： 1vi /etc/netplan/50-cloud-init.yaml 然后接着修改成下面这个样子，网关地址就是之前查看的网关地址（如果乱写是ping不通baidu的就没法正常上网） 123456789network: ethernets: ens33: addresses: [192.168.199.150/24] #IP地址 gateway4: 192.168.199.2 #网关地址 nameservers: addresses: [192.168.199.2] #DNS和网关一样即可 dhcp4: true version: 2 2.修改DNS地址使用命令： 1vi /etc/systemd/resolved.conf 把DNS前面的注释去掉，然后加上114.114.114.114即可 1234[Resolve]DNS=114.114.114.114#FallbackDNS=#Domains= 3.修改主机名 修改cloud.cfg防止重启后主机名还原 123vi /etc/cloud/cloud.cfg#找到这句话的配置默认是false，修改为true即可 修改主机名： 1234567#修改主机名hostnamectl set-hostname 主机名#配置hostscat &gt;&gt; /etc/hosts &lt;&lt; EOF192.186.199.150 主机名EOF 测试ping 一下baidu.com 没有问题，NND","link":"/2020/03/03/Ubuntu18-4%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BD%91%E5%85%B3/"},{"title":"Ubuntu18.4安装docker指定版本以及卸载","text":"前提条件： 需要一台Ubuntu虚拟机 能够连接上这个虚拟机的工具，cmd，putty，FinalShell等等 卸载看最后的连接 步骤： 1，更新数据源：1sudo apt-get update 2，安装所需的依赖：1sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 3，安装GPG证书：1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 4，更新数据源：1sudo apt-get update 5，列出所有可用版本1apt-cache madison docker-ce 6，安装指定的版本 注意我的ubuntu版本是18.4.3server版本的，我测试了高版本的19.03.5~3-0~ubuntu-xenial会报错可以参考下面的链接 报错信息： 1E: Version ' 18.06.2~ce~3-0~ubuntu' for 'docker-ce' was not found 可以参考： https://stackoverflow.com/questions/54471543/e-version-18-06-1ce3-0ubuntu-for-docker-ce-cli-was-not-found 还有一些高版本带来的错误并不能使用这个方式解决。但是我也没有去研究了因为在ubuntu上安装docker用了快一天的时间我最高测试在5:18.09.6~3-0~ubuntu-bionic这个版本是不可以安装的所以我这里安装的是5:18.09.1~3-0~ubuntu-bionic。 使用 sudo apt-get install docker-ce=这里是docker版本号比如 1sudo apt-get install docker-ce=5:19.03.5~3-0~ubuntu-bionic 后来又测试了一下发现安装最高的版本5:19.03.5~3-0~ubuntu-bionic也行，行吧那也就不折腾了 验证是否成功输入命令： 1docker version 输出以下就成功了 12345678910111213141516171819202122232425262728Client: Docker Engine - Community Version: 19.03.5 API version: 1.40 Go version: go1.12.12 Git commit: 633a0ea838 Built: Wed Nov 13 07:29:52 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 19.03.5 API version: 1.40 (minimum version 1.12) Go version: go1.12.12 Git commit: 633a0ea838 Built: Wed Nov 13 07:28:22 2019 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.10 GitCommit: b34a5c8af56e510852c35414db4c1f4fa6172339 runc: Version: 1.0.0-rc8+dev GitCommit: 3e425f80a8c931f88e6d94a8c831b9d5aa481657 docker-init: Version: 0.18.0 GitCommit: fec3683 查看是否正常运行： 1sudo systemctl start docker 1docker info 7，Docker详细的命令操作什么的参考Docker官网： https://www.docker.com/products/docker-hub 参考资料： https://blog.csdn.net/weixin_44270509/article/details/98945146 https://www.jianshu.com/p/cef32b054968 卸载docker参考： https://kiwenlau.com/note/2018/07/10/uninstall-docker/","link":"/2019/12/15/Ubuntu18-4%E5%AE%89%E8%A3%85docker/"},{"title":"docker的安装和常用命令","text":"Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 先决条件： 一个虚拟机virtualbox 一个虚拟机服务器CentOS7 一台电脑 1)，在linux上安装docker详细步骤： 1，首先检查内核版本必须是3.0以上；执行命令1uname -r 2，安装docker；执行命令1yum install docker 中间会提示是否进行安装，输入Y即可安装（中间可能会提示两次） 注意：如果出现下面这个错误1Job for docker.service failed because the control process exited with error code. See &quot;systemc tl st 请参考这篇博客：连接 3，启动docker;执行命令1systemctl start docker 启动： 1docker -v 4，开机启动docker；执行命令1systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 5，停止docker；执行命令1systemctl stop docker 2）、容器操作软件镜像（QQ安装程序）—–运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤:1，搜索镜像1docker search tomcat 2，下载（拉取）tomcat1docker pull tomcat 3，根据镜像启动容器1docker run --name mytomcat -d tomcat:latest 4，查看运行中的容器1docker ps 5，停止运行中的容器1docker stop 容器ID 6，查看所有的容器1docker ps -a 7，启动一个容器1docker start 容器ID 8，删除一个容器1docker rm 容器ID 9，启动一个做了端口映射的tomcat1docker run -d -p 8888:8080 tomcat -d：后台运行 -p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口 效果：我们访问的地址是：你的虚拟机IP后面加上:8888 如果不行请检查以下防火墙的状态 1service firewalld status 关闭防火墙 1service firewlld stop 需要参考更多命令: https://docs.docker.com/engine/reference/commandline/docker/ 当然每一个镜像也有说明 用一个镜像启动多个容器 3）、安装MySQL示例1docker pull mysql 如果你是直接按下面这样启动 12[root@bogon ~]# docker run --name mysql101 -d mysql3fe3ffd2e84d4616e1bdbbb9cd4e222cf55db41b0a4cac3b94ca1f91b503e669 使用docker ps -a 123[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3fe3ffd2e84d mysql &quot;docker-entrypoint...&quot; 2 minutes ago Exited (1) 2 minutes ago mysql101 mysql是没有启动的 我们查看它的日志 123[root@bogon ~]# docker logs 3fe3ffd2e84derror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD 这里显示，我们没有指定mysql得密码 正确的显示 12[root@bogon ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb9b83342a016a43a49a9e4c72b6fd71dc0b6f490c52c7b7916df3c33e4239864 但是这样启动后还是访问不到,我们还需要映射一个端口;在前面加上-p 12[root@bogon ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlf7045f7938e6af57f0f1fff4428cc47d02f62770f938813a0eab413ed20e8e7b 然在客户端测试 然后mysql的官网说了这么一段话,大概就是后面可以加上其他配置 比如: 1[root@bogon ~]# docker run -p 3307:3306 --name mysql03 -e MYSQL_ROOT_PASSWORD=123456 -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 测试： 结束~","link":"/2019/10/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"SpringBoot入门学习笔记","text":"Spring Boot 是一个轻量级框架，可以完成基于 Spring 的应用程序的大部分配置工作；这里来自官方文档的解释:传送门; 示例中使用的是 Spring Boot V1.5.2版本,推荐使用更高版本; 测试环境软件: JDK 8 for Windows, Mac, and Linux Eclipse IDE for Windows, Mac, and Linux。(用的2019版本) Apache Maven for Windows, Mac, and Linux。(学习用的3.5) SpringBoot是什么Spring Boot的目的是提供一组工具,可以方便构建Sping应用程序 Spring:难配置 之前学习三大框架(Spring+SpringMVC+Mybatis)的时候满天的配置,一个”HelloWorld”都需要配置大量工作，这虽然没有什么不好,Spting是一个优雅的框架集合，需要小心协调才能正确工作，但这种优雅的代价是配置变得很复杂(别提XML)。 所以可以使用：SpringBoot来解决! SpringBoot官网官网翻译过来是： Spring Boot可以轻松创建独立的，生产级的基于Spring的应用程序，您可以“运行”。 我们对Spring平台和第三方库采取了自以为是的观点，因此您可以尽量少开始。大多数Spring Boot应用程序只需要很少的Spring配置。 开始使用Spring Boot1，新建Maven项目在Eclipse中，点击File–&gt;New Project选择Maven–&gt;Maven Project勾选上Select project name and location(如下图1所示)然后点击Next 图1 选择 Maven 属性设置(如图2所示) Group Id: com.bjq Artifact Id: HelloSpringBoot Version: 0.0.1-SNAPSHOT Package: jar 从SpringBoot做集成;Parent Project里面的 Group Id: org.springframework.boot Artifact Id: spring-boot-starter-parent Version: 1.5.2.RELEASE 点击Finish 图2 创建完成之后项目的目录(图3所示)： 图3 上面可以看到他给我们默认的JDK是1.6版本的，而和我使用的JDK版本不符合,所以需要在Pom.xml文件中修改JDK版本 1234&lt;!-- 修改JDK版本 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; 在Pom.xml通过配置SpringBoot启动器来注入Jar包; 什么是启动器呢？其实就是一些jar包的集合,SpringBoot提供了44启动器;配置SpringBoot启动后可以看到项目中添加了一个Maven Dependencies集合包 4.1 spring-boot-starter-web 支持全栈式的Web开发，包括了tomcat和SpringBoot等jar 4.2 spring-boot-starter-jdbc 支持Spring以jdbc方式操作数据库的jar包集合 4.3 spring-boot-starter-redis 支持redis键值对的操作 1234567&lt;!--SpringBoot的启动器 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2，编写HelloWorld1，首先我们可以新建一个名为控制器的HelloWorld类 123456789101112131415161718192021package com.bjq.controller;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWorld { @RequestMapping(&quot;/hello&quot;) @ResponseBody public Map&lt;String,Object&gt; showHelloWorld(){ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;msg&quot;, &quot;helloWorld&quot;); return map; } } 2，在SpringBoot里面启动需要配置一个启动类；新建一个类叫做APP.java(名字可以随便起) 然后右键run(java Apllcation) 123456789101112package com.bjq;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//写上@SpringBootApplication表示是一个SpringBoot的启动器@SpringBootApplicationpublic class APP { public static void main(String[] args) { SpringApplication.run(APP.class, args); }} 2.1运行的时候可能有以下出错情况 12345678910111213141516171819202122232425java.net.BindException: Address already in use: bind at sun.nio.ch.Net.bind0(Native Method) ~[na:1.8.0_211] at sun.nio.ch.Net.bind(Unknown Source) ~[na:1.8.0_211] at sun.nio.ch.Net.bind(Unknown Source) ~[na:1.8.0_211] at sun.nio.ch.ServerSocketChannelImpl.bind(Unknown Source) ~[na:1.8.0_211] at sun.nio.ch.ServerSocketAdaptor.bind(Unknown Source) ~[na:1.8.0_211] at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:210) ~[tomcat-embed-core-8.5.11.jar:8.5.11] at org.apache.tomcat.util.net.AbstractEndpoint.start(AbstractEndpoint.java:980) ~[tomcat-embed-core-8.5.11.jar:8.5.11] at org.apache.coyote.AbstractProtocol.start(AbstractProtocol.java:573) ~[tomcat-embed-core-8.5.11.jar:8.5.11] at org.apache.catalina.connector.Connector.startInternal(Connector.java:993) [tomcat-embed-core-8.5.11.jar:8.5.11] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [tomcat-embed-core-8.5.11.jar:8.5.11] at org.apache.catalina.core.StandardService.addConnector(StandardService.java:225) [tomcat-embed-core-8.5.11.jar:8.5.11] at org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer.addPreviouslyRemovedConnectors(TomcatEmbeddedServletContainer.java:247) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer.start(TomcatEmbeddedServletContainer.java:190) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.startEmbeddedServletContainer(EmbeddedWebApplicationContext.java:297) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.finishRefresh(EmbeddedWebApplicationContext.java:145) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:545) [spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE] at com.bjq.APP.main(APP.java:10) [classes/:na]等等的.............. 2.2引起这个错误的原因是:由于你的默认8080端口是被占用的（我的端口默认是被占用了）当然如果你的端口号没有被占用的话,应当是成功了的 解决办法: 实现 EmbeddedServletContainerCustomizer接口的customize方法 12345678910111213141516171819202122232425262728package com.bjq.controller;import java.util.HashMap;import java.util.Map;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWorld implements EmbeddedServletContainerCustomizer { @RequestMapping(&quot;/hello&quot;) @ResponseBody public Map&lt;String,Object&gt; showHelloWorld(){ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;msg&quot;, &quot;helloWorld&quot;); return map; } @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8003);//把默认端口号改成8003端口号 } } 运行控制台界面: 打开浏览器输入：http://localhost:8003/hello（如下图所示) 完成:到此完成了SpringBoot的第一个程序参考资料: 万能的百度和谷老师 以及不太聪明的脑子","link":"/2019/08/29/SpringBoot%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java反射机制","text":"一，Java 反射机制概述本质上Java反射是在 运行中 可以动态的加载某一个类，并且能知道这个类的所有的方法；对于任意一个 对象都可以动态的调用这个对象的某一个方法 ，这种动态获取信息及动态调用方法的功能称为Java的反射机制。 二，问题我们需要动态的获取某一个类的信息，以及这个它的 属性， 方法，能否调用它的任意的一个方法？ 答案：当然是可以的 三，反射的基础要先理解Class 这个类，因为Class 这个类是反射的基础： 3.1：那么 Class 算是一个对象吗？Java 是一项面对对象语言，万物皆对象，对象是一个类的实例，所以类是java.lang.Class类的实例对象，而 Class 是所有类的类（This is a class named Class），Class 类是类的类型，也就是类的类型。 3.2：字节码文件： .class 被称为字节码文件，这个文件会被 load 到内存中，也可以看做是一个对象 3.3：字节码文件的对象的类型是什么？Class 类型 3.4：获取类字节码文件的三种方式。1，三种方式代码如下： 1234567891011121314151617181920212223242526public static void main(String[] args) throws ClassNotFoundException {// Object类中的getClass()方法// 字节码加载时机: new一个类的时候 Person person = new Person(); // 只会加载一次 所以是相同的 创建对象根据 对象.class 来创建 Person person1 = new Person();// 一个类的字节码文件对象 在整个运行过程当中 只会加载一次 Class&lt;? extends Person&gt; aClass = person.getClass(); Class&lt;? extends Person&gt; aClass1 = person1.getClass(); System.out.println(aClass == aClass1); //true System.out.println(person.equals(person1));// 类型 Class 属性 Class&lt;Integer&gt; integerClass = int.class;// 使用forName方法 Class.forName(&quot;com.bjq.reflection.Student&quot;);} 2，字节码文件加载时机： new 一个类的时候 访问一个类的静态成员的时候 调用一个类的静态方法的时候 通过反射的方式床 个类的字节码对象的时候 创建 个子类对象的时候 java 命令执行 个字节码文件的时候 3，字节码文件对象的组成： .class 文件对应的是 –&gt; class 类来的 反射就 是用来 获取字节码文件对象里面的内容 四、获取类的信息4：获取字节码文件对象中的构造方法123456789101112131415161718192021222324252627282930313233343536373839404142package com.bjq.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class TestConstructor { public static void main(String[] args) { Person person = new Person(&quot;你好&quot;,18);// 1. 获取字节码文件对象 Class clazz = Person.class;// 2.获取里面的构造方法 Constructor[] constructors = clazz.getConstructors();// 3. 获取构造方法// for (Constructor constructor : constructors) {//// System.out.println(constructor);//// }// 4.获取指定的构造方法对象 try { Constructor constructor = clazz.getConstructor(String.class);// 用构造器对象创建类的实例 里面的参数和字节码文件对象对应的类型 Object object = constructor.newInstance(&quot;李四&quot;); System.out.println(object); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } }} Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.bjq.reflection;import java.util.ArrayList;import java.util.List;public class Person {// 单例模式 //private static final Person per = new Person();// 多例模式 //private static List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); private String name; private int age;// 设置为private 防止外部类 new 这个类 public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; } public Person(int age) { this.age = age; } public Person() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void name(){ System.out.println(&quot;你好，这是我的名字&quot;); } @Override public String toString() { return &quot;haha&quot;; }} 4.1：获取字节码文件对象中的私有构造方法 123456789101112131415161718192021222324252627282930package com.bjq.reflection.v1;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;// 用反射完整的创建一个类的实例public class TestDeclaredConstructor { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //Person person = new Person();// 得到字节码文件对象 Class clazz = Person.class;// 得到对象类中的私有构造方法对象 Constructor declaredConstructor = clazz.getDeclaredConstructor();// 设置暴力访问 declaredConstructor.setAccessible(true);// 用反射的方式创建该类对象 Object object = declaredConstructor.newInstance(); System.out.println(object); }} Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.bjq.reflection.v1;public class Person {// 单例模式 //private static final Person per = new Person();// 多例模式 //private static List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); private String name; private int age;// 设置为private 防止外部类 new 这个类 public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; } public Person(int age) { this.age = age; } private Person() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void name(){ System.out.println(&quot;你好，这是我的名字&quot;); } @Override public String toString() { return &quot;haha&quot;; }} 4.2：除了上面这种方式呢还有一种便携的方式(不直接使用构造器对象) JDK 会自动帮我们使用：使用下面这种方式呢，有几个缺陷，都写在了 注释当中， 当然也可以动手实验 即可 12345678910111213141516171819202122232425package com.bjq.reflection.v2;import com.bjq.reflection.v1.Person;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;// 还有便携的一种方式 也可以获取public class TestDemo { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { /** * 以这种方式获取有以下的缺陷 * 1. 无法获取构造方法为 private * 2. 只能获取无参的构造方法 */ Class clazz = Student.class; Object object = clazz.newInstance(); System.out.println(object); }} Student.java 12345678910111213package com.bjq.reflection.v2;public class Student { private Student() { } @Override public String toString() { return &quot;哈哈&quot;; }} 4.3：利用反射调用Student类的 Method：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.bjq.reflection.v3;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//利用反射调用Student类的methodpublic class TestDemo { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {// 得到文件字节码文件对象 Class clazz = Student.class;// 得到字节码对象中所有的Method对象 /** Method[] methods = clazz.getMethods(); for (Method method : methods) { System.out.println(method); } **/// 得到特定的方法// 第一个参数 ： 方法的名字// 第二个参数： 参数类型的字节码文件对象 如果是String 可以写String.class 如果没有写成 null Method name = clazz.getDeclaredMethod(&quot;eat&quot;,null); /** * 正常的方法调用 * 对象名.方法名(参数) * 反射的调用方式是反过来的 * 方法名.对象 + （方法对象.invoke(对象,参数)） */ // 暴力访问 name.setAccessible(true); name.invoke(clazz.newInstance(),null); //System.out.println(name); }} Student.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.bjq.reflection.v3;public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student() { }// 换成private private void eat(){ System.out.println(&quot;this is myname&quot;); } @Override public String toString() { return &quot;哈哈&quot;; }} 4.4：利用反射调用Student类的Field对象： 1234567891011121314151617181920212223242526272829303132333435package com.bjq.reflection.v4;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//利用反射调用Student类的Field对象public class TestDemo { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {// 得到文件字节码文件对象 Class clazz = Student.class; Object object = clazz.newInstance(); Student student = new Student();// 得到Field对象 /** * Field[] fields = clazz.getFields(); * for (Field field : fields) { System.out.println(field); * } */// 得到指定Field对象 Field field1 = clazz.getField(&quot;name&quot;); // 得到 public的 值 Field field2 = Student.class.getDeclaredField(&quot;age&quot;); // 得到 private 的值// 给Field 设置值 field2.setAccessible(true); field1.set(student,&quot;你好&quot;); field2.set(student,18); System.out.println(field2.get(student)); }} Student.java 1234567891011121314151617181920212223package com.bjq.reflection.v4;//利用反射访问Student类的 parameterpublic class Student { public String name; private int age; public Student(){ }// 换成private private void eat(){ System.out.println(&quot;this is myname&quot;); } @Override public String toString() { return &quot;哈哈&quot;; }} 五，总结 反射是用来干嘛的，反射可以简单理解为一个程序中 外挂反射打破了 Java语言的封装性 （这样做有好处，当然也有坏处）在反射面前所有的 类 方法，属性都是裸奔的。 反射的特点就是： 在运行期间可以动态的加载某一个类进行，动态的new 一个对象 ，动态的去调用这个对象某一个方法。 ENd 追加：如何获取类里面的方法传入参数并且调用 代码：Robot.java 1234567891011121314151617181920212223242526package com.bjq.reflection.v5;/** * Created with IntelliJ IDEA. * Create: jealous * Date: 2021/2/17 * Time: 17:34 */public class Robot { public String name; public void sayHid(String helloSentence){ System.out.println(&quot;helo&quot;+name); } private String helloThrow(String tag){ return &quot;Hello&quot; + tag; }} 利用反射进行调用并且执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.bjq.reflection.v5;import jdk.management.resource.internal.inst.SocketOutputStreamRMHooks;import javax.print.DocFlavor;import java.io.File;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * Created with IntelliJ IDEA. * Create: jealous * Date: 2021/2/17 * Time: 17:37 */public class ReflectionTest { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class rc = Class.forName(&quot;com.bjq.reflection.v5.Robot&quot;); Object object = (Robot)rc.newInstance(); System.out.println(&quot;helloThrow&quot; + rc.getName()); Method me = rc.getDeclaredMethod(&quot;helloThrow&quot;,String.class); me.setAccessible(true);// 调用invoke方法传入参数 Object bog = me.invoke(object, &quot;BOG&quot;); System.out.println(bog); Method sayHid = rc.getMethod(&quot;sayHid&quot;, String.class);// 调用sayHid方法传入参数值为name sayHid.invoke(object, &quot;name&quot;); Field field2 = Robot.class.getDeclaredField(&quot;name&quot;); // 得到 private 的值 field2.setAccessible(true); field2.set(object,&quot;你的英文名字:&quot;); sayHid.invoke(object, &quot;name&quot;); System.out.println(System.getProperty(&quot;java.class.path&quot;)); }}","link":"/2020/05/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"shiro快速入门","text":"Shiro简介：就是一个用于身份验证，授权，认证，加密等等。功能；来自官网的简介: Apache Shiro™是一个功能强大且易于使用的 Java 安全框架，用于执行身份验证、授权、加密和会话管理。借助 Shiro 易于理解的 API，您可以快速轻松地保护任何应用程序 - 从最小的移动应用程序到最大的 Web 和企业应用程序。 官网地址：http://shiro.apache.org/ 与Spring Security的对比市面上也不止这一个安全框架与之比较出名还有Spring Security 这是官网：https://spring.io/projects/spring-security 两者之间的对比： Shiro： 比较灵活简单，可以脱离Spring，支持多种数据源（LDAP,JDBC,Kerberos,等等），还有很多好处这里就不一一说了 Spring Security： 功能比较全大部分功能都给你实现了；不可以脱离Spring。权限控制力度很细 具体用哪个都要看实际的情况，如果你是SpringBoot完全可以使用Spring Security，选哪个用哪个可以根据实际情况来定 使用Shiro导入依赖：(官网好像出到1.4.2版本了) 123456789101112131415&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; shiro官网示例：（原文的运行方式或者原文输出是英文我给翻译了下） 参考：http://shiro.apache.org/tutorial.html 配置官网原话：Shiro通过基于文本的INI配置提供默认的”公分母”解决方案人们已经厌倦了使用笨重的XML文件，而且INI易于阅读，易于使用，而且只需要很少的依赖项INI 可以有效地用于配置简单的对象图形，如 SecurityManager。等等… 因此我们需要在resources目录下新建一个后缀为.ini的文件; 12345678910111213141516171819202122232425# =============================================================================# 教程INI配置## 用户名/密码基于经典的梅尔·布鲁克斯（Mel Brooks）的电影“ Spaceballs” :)# =============================================================================# -----------------------------------------------------------------------------# 用户及其（可选）分配的角色# 用户名=密码，role1，role2，...，roleN# -----------------------------------------------------------------------------[users]root = secret, adminguest = guest, guestpresidentskroob = 12345, presidentdarkhelmet = ludicrousspeed, darklord, schwartzlonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# 具有分配权限的角色# 角色名 = perm1，perm2，...，permN# -----------------------------------------------------------------------------[roles]admin = *schwartz = lightsaber:*goodguy = winnebago:drive:eagle5 引用配置：前面已经定义了一个INI文件，可以新建一个演示类更改方法以反映以下更新：SecurityManagermain 这其中有很多的细节解释以及大部分代码也可以参考官网说明：http://shiro.apache.org/tutorial.html； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TestShiro { private static final transient Logger log = LoggerFactory.getLogger(TestShiro.class); public static void main(String[] args) { System.out.println(&quot;My First Apache Shiro Application&quot;); //1.这个实现反映了Shiro对工厂方法设计模式的支持。前缀是一个资源指示器，用于告诉 shiro 从何处加载 ini 文件（其他前缀，如 和 也受支持）。IniSecurityManagerFactoryshiro.iniclasspath:url:file: Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2.调用 该方法，该方法分析 INI 文件并返回反映配置的实例。factory.getInstance()SecurityManager SecurityManager securityManager =factory.getInstance(); //3. SecurityUtils.setSecurityManager(securityManager); //4. //System.exit(0); //我们的 SecurityManager 已准备就绪 Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; ); String value = (String) session.getAttribute(&quot;someKey&quot;); if (value.equals(&quot;aValue&quot;)) { System.out.println(&quot;检索到正确的值! [&quot; + value + &quot;]&quot;); } if ( !currentUser.isAuthenticated() ) { UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;); token.setRememberMe(true); currentUser.login(token); try { currentUser.login(token); } catch (UnknownAccountException uae) { System.out.println(&quot;没有用户名为 &quot; + token.getPrincipal()+&quot;的用户&quot;); } catch (IncorrectCredentialsException ice) { System.out.println(&quot;密码帐户 &quot; + token.getPrincipal() + &quot; 是不正确的!&quot;); } catch (LockedAccountException lae) { System.out.println(&quot;用户名账户 &quot; + token.getPrincipal() + &quot; 是锁着的 &quot; + &quot;请联系您的管理员解锁.&quot;); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { //unexpected condition? error? } } System.out.println(&quot;用户 [&quot; + currentUser.getPrincipal() + &quot;] 已成功登录.&quot;); if (currentUser.hasRole(&quot;schwartz&quot;)) { System.out.println(&quot;愿施瓦茨与您同在!&quot;); } else { System.out.println(&quot;你好,凡人.&quot;); } if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) { System.out.println(&quot;你可以使用光剑戒指。明智地使用它.&quot;); } else { System.out.println(&quot;对不起，光剑戒指只供lightsaber使用&quot;); } if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) { System.out.println(&quot;您被允许使用车牌（id）'eagle5'驱动'winnebago'. &quot; + &quot;这是钥匙-玩得开心!&quot;); } else { System.out.println(&quot;抱歉，您不允许驾驶“ eagle5” winnebago!&quot;); } currentUser.logout(); System.exit(0); }} 自定义在看懂大部分代码的意思之后可以写一下自己的身份验证：大概这几个步骤： 认证：简单来说就是看是不是zhangsan或者lisi这个人。只不过是基于Shiro的认证方式。 导包就不说了和之前一样； 然后配置文件： 相当于准备一些用户的身份(有点模拟数据的意思): 12345[users]#模拟从数据库查询用户#数据格式 用户名=密码zhangsan=123456lisi=654321 *新建一个测试类或者test方法都可以都ok** 每一行的都有相应的注释; 1234567891011121314151617181920212223242526272829303132333435363738package cn.itcat.shiro;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Test;public class ShiroTest01 { @Test public void testLogin(){ //1.根据配置文件创建SecurityManagerFactory Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-test-1.ini&quot;); //2.通过工厂获取SecurityManager SecurityManager securityManager = factory.getInstance(); //3.将SecurityManager绑定到当前运行环境 SecurityUtils.setSecurityManager(securityManager); //4.从当前运行环境中构造subject Subject subject = SecurityUtils.getSubject(); //5.构造shiro登录的数据 String username =&quot;lisi&quot;; String password =&quot;654321&quot;; UsernamePasswordToken token = new UsernamePasswordToken(username,password); //6.主体登陆 subject.login(token); //7.验证用户是否登陆成功 System.out.println(&quot;用户是否登陆&quot;+subject.isAuthenticated()); //8.获取用户登录成功的数据 System.out.println(subject.getPrincipal()); }} 输出： 12用户是否登陆truelisi Shiro执行流程：","link":"/2020/01/11/shiro%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"win10配置jdk环境变量","text":"1），首先我们得去官网下载相应的jdk版本这里是jdk8的连接： https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 因为官方需要一个账号才能进行下载：这里事先下载好的一个jdk8 链接：https://pan.baidu.com/s/1VsjJiGNTX0Rhb2BLDliWLw提取码：ladh 2)，然后点开桌面右键桌面上“我的电脑”&gt;&gt;“属性”，在弹出的页面上点击“高级系统设置”。 3)，在弹起的页面选择环境变量 4)，在系统变量里面点击新建一个名为 JAVA_HOME 的变量变量值就是你jdk安装的路径位置我这里是c盘下面的 如图所示。 5），还得新建一个名为 classpath 的变量值为 %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar。如图所示： 6)，最后我们设置 Path 环境变量，该变量已经存在，所以在列表中选择Path 点击编辑按钮 添加两个变量值为 %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 最后点击确认按钮即可 7)，最后在命令行中输入：java -version,出现如下信息就说明安装成功 参考了这篇博客: https://www.cnblogs.com/boringwind/p/8001300.html 结束~","link":"/2019/11/14/win10%E9%85%8D%E7%BD%AEjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"关于那个她","text":"85e440b4f1139044aebf7b1a90bcfe7961ec8b4d76a35869d6d3f60123d737ff8635d87ca02d96f9906436b84c7c9317061249716e9dfc4bb1b95f0b7c6386f72a2b1fdc8708c215f0cb8d1ab59e359a320e7a45e682156a09662d59df8b5557097ce9c37b08bb55a9ef10f808b84f759337edba02ab4f0c9857feea2136ee00a586cfc807ee57efd5a474589317462d2f663f322b74da341932db36fcfcc4c70e6676e42d945b0cb9754e2d9a5236e8fb84c61ad1731d52124c9f1abc35845c3b4bb68fcbf7784cc9890c4a99d44aabd1b7e399ec4e9eb1e1ef0f98580737ede482b3c9b801ed55ba0db85b33597e3396c5af719fd55087b383ff77c6868ab6a76eb85811f3d9f669ac7ded8d1af4d14d00b21ff631bb78e2f835094371cb116049325528781fcce88e7fd85c7585c55ef416b7cc03facc3538d98a29006874db3e4f00640351f1551ebf81b6b82676a2931cdc20a503d1b4fe0d1b5e46b28d64e3dfdc7249dee16fa35354d3fd2cef5f2b296a2a061fe818ecdefdf6defd0b26ed23b3220f38ee8aa835ac2458300fea7c2d4dc24e88d3e364fb51b3e1da05255cb32c74d1dc6681c7440411bbf55774f0f56505e0868fb47a20fe9187307969861e145c04fe278892d1e5e18ccfa9c4c92354eeb151da33e464325203d6c0a99c67e807fac63ed9f4d392980c3ee3dbcba2917abd9a654be3ee06acd63ba4b4d84704b56eda2cf6f970eea2cf8a7491e1c1a28064b3511d43f63abe449a3fecfefbf383a679e8f77d912e2fde0ce8bd36ef54e41de0880065ae86f57be6caa6a9d3635367f602a10a9d2a5a22098982602a19aacf12d9c00d252cf48b5de077a80bf81c987b2fa19f6082f06920943e38c31cdc7e32bbb9c2c88bbacd22417880b4b3b6ad17f59921148c55af1abf8c047d535f0ae743e617912082b531c6da038edfa8994c9f9c921c597daa1cdc0c8de853cba3b9a1937e9f3543b0be2bad76aae703fd5cb52973a24547ff1a848ebbf0702eed2bb5deb3b19a984beb9798969acfce14a715edf68933d6a29c736274a5dae6d0338469bd19b61ee5ccb75512dc578c148e35a2f5b001b9e4640826eec865b697fde43afc8b46a93829db899d87e820d9af054ed7f339586e7c6f1205edc6716dad5e79de9448ddd54ed32e4394a4435b7b92a6b9a5a4edfd21d9c1fdd61f7df990f236104e0536edd42c 请输入密钥","link":"/2019/08/03/%E4%B8%80%E4%B8%AA%E5%93%88%E5%84%BF%E7%9A%84%E7%85%A7%E7%89%87/"},{"title":"一次Fiddler4的使用","text":"1，首先什么是Fiddler？Fiddler是一款免费强大的抓包工具，可以使用它来抓取网上一些请求数据，这里除了PC端之外，手机也可以使用它来进行抓包。 当然了市面上还有一些比如 wireshark，个人觉得学习成本稍微高了一点 下载链接：https://www.telerik.com/download/fiddler AutoResponder自动相应器实际上可以拦截某一个请求，进行如下操作： 重定向到本地的资源 使用Fiddler的内置相应 自定义相应 点击：AutoResponder 1，点击Add Rule 添加一个规则 2，输入一个拦截的网址（我要拦截的是一张图片的url） 3，选择Fiddler内置的一些响应内容，后面可以自定义我们本地的资源内容 4，然后save(保存) 5，如果要让这个规则生效的话把Enable rules和Unmatched requests passthrough勾选上 Enable rules：是指激活这个规则 Unmatched requests passthrough：是指没有匹配的这个规则的就给他忽略掉 1，以下面的网址为例，我就把背景图片给他拦截了内容为404所以显示不出来 2，可以看到左边显示404 3，接下来我们可以把背景图片换成本地得资源，响应内容选择Find a file然后选择一张本地的图片：然后点save 4，再次按住shift+f5刷新即可看到效果。 5，或者是使用一个本地文件资源比如.js文件先把请求的网址放到规则里面然后复制SyntaxView里面的内容 6，到本地进行修改（可以添加一段话或者钓鱼得链接等等之类） 添加一段js代码： 123456var flag = confirm(&quot;恭喜你中将了，是否前往领奖&quot;);if(flag){ window.location.href=&quot;https://yunhao.shop/&quot;;}else{ window.location.href=&quot;http://www.baidu.com&quot;;} 7，效果： 8，还有相关的应用场景可以mock模拟接口请求 9，比如我想修改一下登陆需要返回一张图片或者什么都不返回或者返回其他或者需要修改返回的数据 10，然后点击Raw再接着修改一下里面的内容最后点击save 11，测试接口可以选择本地返回一张图片或者其他文件等等 Composer发包请求可以用来测试后端接口便于查询有没有bug 点击Composer窗口 点击测试网址登录然后把网址拖动到Composer窗口，可以看到我们的请求方式是POST以及我们的请求url，可以看到红色框内是我们的username(这里用的是email)和密码 修改请求体的信息然后再点击Execute发包 这样就完成了发包 断点应用：断点有两种方式：一种全局断点，和局部断点，两者之间的区别就在于全局断点会把所有的请求都给他断点，局部断点就不会。 全局断点： 在此位置点击就会显示一个红色的图标 出现一个红色的T字图标表示的是响应前断点 这个时候你可以去缓冲刷新页面就可以看到页面的请求被捕获到了 双击这个连接，然后就可以看到或修改里面的内容了，完成后点击Run to Completion通过断点。 整个过程可以看作是网络中断 这样就完成了响应前的处理。 响应后断点: 然后再去发送一次请求就可以看到被捕获到了 双击这个连接，就可以修改里面的内容完成后点击Run to Completion通过断点 这样就完成了响应后的处理，如果想关掉断点只需要再点一下红色按钮即可 局部断点:1，在命令行中输入bpu login 然后回车后面加上的login意思是我的请求包含login的时候就会触发断点，这也叫做请求前断点 2，然后再次发送一个请求 3，如果想停止这个断点在命令汗中输入bpu即可停止 响应后断点： 1，在命令行输入bpafter login 2，就可以看到请求被捕获到了 3，然后修改一点内容，点击Run to Completion 4，如果想停止这个断点在命令汗中输入bpafter 即可停止","link":"/2020/02/24/%E4%B8%80%E6%AC%A1Fiddler4%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"使用Jekyll+gitee搭建自己的博客","text":"前言：除了下面要说的这种方式还有一种方式：Hexo+Github 也可以完成搭建，看个人喜好把，因人而异。Hexo+Github搭建博客网上的教程很多这里就不过多赘述了 操作成果：http://lyunqi.gitee.io/lyq/ 开始步骤1，可以先本地安装一下Ruby环境。 因为Jekyll基于Ruby，创建网站的时候可能需要Ruby环境。如果你从未安装过Ruby第一次安装应该不会出现太大的问题，这里我参考了Ruby官网：https://www.ruby-lang.org/en/ 只需要下载你电脑对应的版本即可，完成后可能会弹出一个cmd命令行它还需要下载一些东西完成后会自动关闭 你可以在命令行输入ruby -v来检查ruby是否安装成功，如果输出以下信息代表安装没有问题; 2，在gitee(码云)创建一个网站的参考并且clone到本地。 搭建步骤1.创建gitee仓库 创建或者打开gitee点击头像旁边的+号创建仓库； 仓库名称和你的gitee账户一致（注意!） 介绍可以写可以不写 是否开源：随意 选择语言一点要选不然样式是出不来的别问为什么；我试过了！ 最后点击创建即可 2.创建完成后点击上方的服务然后点击Gitee Pages 3.然后你会看到如下页面，默认是启动按钮，你点击启动即可，上方会出现一个网站地址（这个就是你博客的地址）当然现在什么东西都没有先不要点击访问 2.本地操作 1.在本地找个目录安装jekyll 1gem install jekyll 2.右键打开git bash或者用命令行使用命令把刚创建的仓库clone下来。如下图所示 12git clone 刚创建的仓库地址比如：git clone https://gitee.com/LYunQI/QQY.git 这个时候可以顺便把默认的主题换掉这里我使用了一个比较好看的主题（https://github.com/kitian616/jekyll-TeXt-theme 。找到源文件我们把它给clone下来 如果你不喜欢也可以在网上搜索jekyll主题 很多相关主题 使用命令： 1git clone https://github.com/kitian616/jekyll-TeXt-theme 3.把主题文件夹里面的内容除了.git文件其他全部复制到我们的仓库文件夹下 然后进入这个文件夹内修改_config.yml这个文件的内容把url属性后面写上我们之前gitee上开启pages的网址以及baseurl属性换成用户名；如下图所示 然后在git bash进入我们仓库文件夹内制作版本然后上传 使用命令: 1234git add . //添加所有文件git status //查看有变更的文件git commit -m &quot;first commit&quot; //提交git push origin master //提交到远程的master分支上(默认就是master分支) 4.提交完成后可以返回浏览器点击更新按钮然后再访问http://lyunqi.gitee.io/lyq/ (你gitee pages上方的那个网址) 这个时候就可以看到一个初始化的博客在你的面前了； 如果你想要自己写文章的话就在_posts文件夹下创建一个后缀为.md的文件写自己的文章就OK了； 开启主题导航栏： 这个是我参考别人学来的可以在博客的左边开启一个导航栏找文章的时候岂不美哉。 我们可以在_data/navigation.yml里。添加内容： 注意的是yml配置后面有个空格，它原来有一些国际化的配置你想改就改不想改最好 123456789docs-zh: - title: 导航示例 children: - title: Welcome url: http://lyunqi.gitee.io/lyq/2020/01/18/hello.html - title: Welcome1 url: http://lyunqi.gitee.io/lyq/2018/07/01/welcome.html - title: 官方示例 url: http://lyunqi.gitee.io/lyq/2018/06/01/header-image.html 然后在_posts文件夹下这两个.md的文件配置： 12sidebar: nav: docs-zh 文章有了导航栏但是主页没有我们可以在根目录找到index.htm文件也添加: 最后再把刚改完的文件上传到gitee点击更新最后的成果就是这样子： 可以访问：http://lyunqi.gitee.io/lyq/ 结束~~ 参考资料： 江南一点雨的教程 https://www.bilibili.com/video/av81337324/ http://www.alonemonkey.com/2016/05/20/blog-by-jekyll-hexo/","link":"/2020/01/18/%E4%BD%BF%E7%94%A8Jekyll-gitee%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"title":"使用七牛云SKD上传图片","text":"前言： 之间使用过ucload的SDK来保存图片，使用方法大概都差不多；这里只是记录一下学习的方法 使用步骤：先找到七牛云的官网地址：https://www.qiniu.com/ 然后注册一个账号填写账号密码等….. 温馨提示：你可能需要实名认证不然的话可能使用了不了他的一些服务 注册成功后可以看到有一个管理控制台，点击进入控制台页面找到对象存储页面 然后点击新建空间 1，填写存储空间名称：（可以自己起个名字） 2，存储区域：（可以选择华东也可以选择华北或者其他的） 3，访问控制：选择公开 最后点击确定。 然后我们在密匙管理找到：AccessKey/SecretKey 和你的存储空间(比如我的qiniu-test)的名字一起复制到一个文本中后面有用 然后我们可以新建一个测试demo： 代码：来自官网文档：https://developer.qiniu.com/kodo/sdk/1239/java#upload-file 下次遇到类似情况可以首先查看文档的内容 官网提供了很多不同的使用方式。我们使用导入Maven相关依赖: 12345&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;[7.2.0, 7.2.99]&lt;/version&gt;&lt;/dependency&gt; 下面的代码包括了文件上传（图片上传）以及断点上传（需要上传比较大的文件的时候可以使用这种方式） accessKey/secretKey中的内容是之前复制的内容； bucket 就是你的存储库名字 可以指定覆盖上传加上key即可来达到更新上传的效果 注意 如果覆盖上传看不到效果的话可以在图片链接后面加上一个字符串如下(后面的1234是随机字符可以随便输入)因为七牛云有很多的缓存所以可以使用下面这种方式来刷新 1http://q56hgwwcw.bkt.clouddn.com/test?t=1234 代码来官网文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package cn.itcast.qiniu;import com.google.gson.Gson;import com.qiniu.common.QiniuException;import com.qiniu.http.Response;import com.qiniu.storage.Configuration;import com.qiniu.storage.Region;import com.qiniu.storage.UploadManager;import com.qiniu.storage.model.DefaultPutRet;import com.qiniu.storage.persistent.FileRecorder;import com.qiniu.util.Auth;import org.junit.Test;import java.io.IOException;import java.nio.file.Paths;public class QiniuDemo { /** * 将图片上传到七牛云 * 1.更新图片 * 2.访问图片 * */ @Test public void testUpload(){ //构造一个带指定 Region 对象的配置类 Configuration cfg = new Configuration(Region.huadong()); //...其他参数参考类注释 UploadManager uploadManager = new UploadManager(cfg); //...生成上传凭证，然后准备上传 String accessKey = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; String secretKey = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; String bucket = &quot;qiniu-test&quot;; //如果是Windows情况下，格式是 D:\\\\qiniu\\\\test.png String localFilePath = &quot;D:\\\\saas\\\\09-图片上传及Jasper\\\\01-文件上传与PDF报表入门\\\\资源\\\\资源\\\\003.jpg&quot;; //默认不指定key的情况下，以文件内容的hash值作为文件名 代表存储空间的文件名 String key = &quot;test&quot;; //身份认证的一个操作 Auth auth = Auth.create(accessKey, secretKey); //指定覆盖上传 String upToken = auth.uploadToken(bucket,key); try { //上传操作 Response response = uploadManager.put(localFilePath, key, upToken); //解析上传成功的结果 DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class); System.out.println(putRet.key); System.out.println(putRet.hash); } catch (QiniuException ex) { Response r = ex.response; System.err.println(r.toString()); try { System.err.println(r.bodyString()); } catch (QiniuException ex2) { //ignore } } } /** * 断点续传(也就是中间如果出现网络波动，下一次可以继续在上次地方重新上传) * 如果你需要传递一个比较大的文件就可以使用这种方式 * 不止是传图片也可以是文件 */ @Test public void testUpload2(){ //构造一个带指定 Region 对象的配置类 Configuration cfg = new Configuration(Region.region0()); //...其他参数参考类注释 //...生成上传凭证，然后准备上传 String accessKey = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; String secretKey = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; String bucket = &quot;qiniu-test&quot;; //如果是Windows情况下，格式是 D:\\\\qiniu\\\\test.png String localFilePath = &quot;D:\\\\saas\\\\09-图片上传及Jasper\\\\01-文件上传与PDF报表入门\\\\资源\\\\资源\\\\test.xlsx&quot;; //默认不指定key的情况下，以文件内容的hash值作为文件名 String key = &quot;testExcel&quot;; Auth auth = Auth.create(accessKey, secretKey); String upToken = auth.uploadToken(bucket); String localTempDir = Paths.get(System.getProperty(&quot;java.io.tmpdir&quot;), bucket).toString(); System.out.println(localFilePath); try { //设置断点续传文件进度保存目录 FileRecorder fileRecorder = new FileRecorder(localTempDir); UploadManager uploadManager = new UploadManager(cfg, fileRecorder); try { Response response = uploadManager.put(localFilePath, key, upToken); //解析上传成功的结果 DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class); System.out.println(putRet.key); System.out.println(putRet.hash); } catch (QiniuException ex) { Response r = ex.response; System.err.println(r.toString()); try { System.err.println(r.bodyString()); } catch (QiniuException ex2) { //ignore } } } catch (IOException ex) { ex.printStackTrace(); } }} 官网还有其他的上传方式： 学习的最好方式是跟着文档来 End","link":"/2020/02/05/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91SKD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"},{"title":"使用jsDelivr加速github图床效果","text":"为什么会弄这个加速？本意是想换一下博客的图片然后发现博主使用了cdn加速于是找到博主的GitHub地址一顿查然后找到jsDelivr jsDelivr官网地址：https://www.jsdelivr.com/?docs=gh 上面写了有一些语法并没看到实际操作的示例。。。。。 开始步骤首先需要登陆你的GitHub账号，创建一个图床存储库步骤—&gt; New repository 然后你可以直接点击这个地址：https://github.com/settings/tokens； 或者点击Settings—-&gt;Developer settings可以看到这个页面 2.点击之后出现如下页面；填选完之后滑到最后点击Generate token按钮即可看到你的token信息然后复制（不然再次刷新就找不到了） 第二步需要借助一个工具这个工具下载地址：https://github.com/Molunerfinn/PicGo/releases 直接下载.exe可执行文件就行打开软件页面找到Github图床需要设置里面的内容 配置说明 设定仓库名：写上你的GitHub加上你的图床存储库名称比如我的：VIlboys/blog_img 设定分支名：直接填写master分支就行 设定Token：填写之前你创建令牌的时候复制的token值 指定存储路径：填写你想要存储图片的路径；比如我就想存储在posts_img/这个文件夹下（你可以根据自己喜好来设置） 设定自定义域名：这个是jsDelivr的配置按照惯例可以按如下这么配置详细说明可能得自己去搜一下才知道 https://cdn.jsdelivr.net/gh/用户名/图床仓库名 然后点击确定回到上传区可以上传一张图片在相册里面找到图片的链接格式就是这样的： https://cdn.jsdelivr.net/gh/VIlboys/blog_img/posts_img/图片名称.png 你再复制就可以到你的博客中使用了 结束~~~ 参考资料： https://blog.iljw.me/2019/05/jsdelivr-cdn-github.html https://blog.csdn.net/pilihaotian/article/details/103338003","link":"/2020/01/15/%E4%BD%BF%E7%94%A8jsDelivr%E5%8A%A0%E9%80%9Fgithub%E5%9B%BE%E5%BA%8A%E6%95%88%E6%9E%9C/"},{"title":"使用前端脚手架工程的出错记录","text":"环境： node.js版本是10.16.0 npm版本是6.9.0 运行命令： 1npm install 报错记录 第一句话是说没有找到Python导致发生异常 12345678910111213141516171819202122232425gyp ERR! stack Error: Can't find Python executable &quot;python&quot;, you can set the PYTHON env variable.gyp ERR! stack at PythonFinder.failNoPython (D:\\src\\SpringBoot\\Saas\\ScaffoldingWork\\project-saas-hrm-vue-master\\node_modules\\node-gyp\\lib\\configure.js:484:19)gyp ERR! stack at PythonFinder.&lt;anonymous&gt; (D:\\src\\SpringBoot\\Saas\\ScaffoldingWork\\project-saas-hrm-vue-master\\node_modules\\node-gyp\\lib\\configure.js:509:16)gyp ERR! stack at callback (D:\\src\\SpringBoot\\Saas\\ScaffoldingWork\\project-saas-hrm-vue-master\\node_modules\\graceful-fs\\polyfills.js:295:20)gyp ERR! stack at FSReqWrap.oncomplete (fs.js:153:21)gyp ERR! System Windows_NT 10.0.18362gyp ERR! command &quot;C:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\ScaffoldingWork\\\\project-saas-hrm-vue-master\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js&quot; &quot;rebuild&quot; &quot;--verbose&quot; &quot;--libsass_ext=&quot; &quot;--libsass_cflags=&quot; &quot;--libsass_ldflags=&quot; &quot;--libsass_library=&quot;gyp ERR! cwd D:\\src\\SpringBoot\\Saas\\ScaffoldingWork\\project-saas-hrm-vue-master\\node_modules\\node-sassgyp ERR! node -v v10.16.0gyp ERR! node-gyp -v v3.8.0gyp ERR! not okBuild failed with error code: 1npm WARN axios@0.18.0 had bundled packages that do not match the required version(s). They have been replaced with non-bundled versions.PS D:\\src\\SpringBoot\\Saas\\ScaffoldingWork\\project-saas-hrm-vue-master&gt; npm install --global windows-build-toolnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmjs.org/windows-build-tool - Not foundnpm ERR! 404npm ERR! 404 'windows-build-tool@latest' is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\jealous\\AppData\\Roaming\\npm-cache\\_logs\\2019-12-22T11_38_12_717Z-debug.log 解决的办法： 1，使用管理员运行cmd 2，然后使用命令： 1npm i -g node-sass 3，然后进入到项目文件夹使用命令 1npm install 4，最后，运行使用命令： 1npm run dev 看到下面这个图片就表示可以成功访问8081这个端口 参考： https://stackoverflow.com/questions/45801457/node-js-python-not-found-exception-due-to-node-sass-and-node-gyp","link":"/2019/12/22/%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/"},{"title":"关于集合容器的回顾","text":"可以这么理解：集合也可以说是容器，总之是用来装东西的； 所有的集合的类都在java.util这个包下面，有很多的集合类，可以查看API的文档就得知了 容器API的类图结构如下图 Set：元素放入没有顺序，元素不可重复； List：元素放入有顺序，元素可以重复； 注意：怎么判断两个对象重复？，这个两个对象互相的equles说明这两个对象重复了 Map：定义了键值对的存储方法 小栗子: 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class BasicContainer{ public static void main(String[] args){ Collection c = new HashSet(); c.add(&quot;hello&quot;); c.add(new Name(&quot;f1&quot;,&quot;f2&quot;)); c.remove(&quot;hello&quot;); c.remove(new Integer(100)); System.out.println(c.remove(new Integer(100))); System.out.println(c); } }class Name { private String firstName,lastName; public Name(String firstName, String lastName){ this.firstName = firstName; this.lastName = lastName; } public String getFirstName(){ return firstName; } public String getLastName(){ return lastName; } public String toString(){ return firstName + &quot; &quot; +lastName; }} 容器类对象在调用remove，contains等等方式时需要比较对象是否相等，这会涉及到对象类型的equals，主要用的是equals方法有时候也会需要用到hashCode方法，所以重写equals对象应该重写hashCode，重写hashCode方法应该重写equals方法 相等的对象应该具有相等的hashcode;如果重写一个对象equals方法，必须要重写这对象的hashcode方法，两个对象互相的equals，两个对象必须具备同样的hashcode 重写equals和hashCode方法之后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;public class BasicContainer{ public static void main(String[] args){ Collection c = new HashSet(); c.add(&quot;hello&quot;); c.add(new Name(&quot;f1&quot;,&quot;l1&quot;)); c.add(new Integer(100)); c.remove(&quot;hello&quot;); c.remove(new Integer(100)); System.out.println (c.remove(new Name(&quot;f1&quot;,&quot;l1&quot;))); System.out.println(c); } }class Name { private String firstName,lastName; public Name(String firstName, String lastName){ this.firstName = firstName; this.lastName = lastName; } public String getFirstName(){ return firstName; } public String getLastName(){ return lastName; } public String toString(){ return firstName + &quot; &quot; +lastName; } public boolean equals(Object obj) { if (obj instanceof Name) { Name name = (Name) obj; return (firstName.equals(name.firstName)) &amp;&amp; (lastName.equals(name.lastName)); } return super.equals(obj); } public int hashCode() { return firstName.hashCode(); } } Set的小栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;public class BasicContainer{ public static void main(String[] args){ Set s1 = new HashSet(); Set s2 = new HashSet(); s1.add(&quot;a&quot;); s1.add(&quot;b&quot;); s1.add(&quot;c&quot;); s2.add(&quot;a&quot;); s2.add(&quot;b&quot;); s2.add(&quot;c&quot;); s2.add(&quot;d&quot;); //相当于把s1的内容放到了sn里面 Set sn = new HashSet(s1); sn.retainAll(s2); Set su = new HashSet(s1); su.addAll(s2); System.out.println(sn); System.out.println(su); } }class Name { private String firstName,lastName; public Name(String firstName, String lastName){ this.firstName = firstName; this.lastName = lastName; } public String getFirstName(){ return firstName; } public String getLastName(){ return lastName; } public String toString(){ return firstName + &quot; &quot; +lastName; } public boolean equals(Object obj) { if (obj instanceof Name) { Name name = (Name) obj; return (firstName.equals(name.firstName)) &amp;&amp; (lastName.equals(name.lastName)); } return super.equals(obj); } public int hashCode() { return firstName.hashCode(); } } List小栗子:123456789101112List l1 = new LinkedList(); for (int i = 0; i &lt;=9;i++) { l1.add(&quot;a&quot;+i);} System.out.println(l1);Collections.shuffle(l1);System.out.println(l1);Collections.reverse(l1);System.out.println(l1);Collections.sort(l1);System.out.println(l1);System.out.println(Collections.binarySearch(l1, &quot;a5&quot;)); 用那种集合? Array读写快改慢 Linked改快读慢 Hash两者之间 选择合适的就好 Map 接口实现Map接口的类用存储键值对。 Map接口的实现类有HashMap和TreeMap等。 Map类中存储的键值对通过键来标识，所以键值不能重复(互相之间必须eqluas但是使用eqluas效率很低我们使用hashCode方法来比较)； 小栗子: 123456789101112131415161718192021Map m1 = new HashMap();Map m2 = new HashMap();m1.put(&quot;one&quot;,new Integer(1));//可以这么写m1.put(&quot;one&quot;,1);m1.put(&quot;two&quot;,new Integer(2));m1.put(&quot;sort&quot;,new Integer(3));m2.put(&quot;A&quot;,new Integer(1));m2.put(&quot;B&quot;,new Integer(2));System.out.println(m1.size());System.out.println(m1);System.out.println(m1.containsKey(&quot;one&quot;));System.out.println(m2.containsValue(1));if(m1.containsKey(&quot;two&quot;)){ int i = ((Integer)m1.get(&quot;two&quot;)).intValue(); //可以这么写int i = ((Integer)m1.get(&quot;two&quot;)); System.out.println(i);}Map m3 = new HashMap(m1);m3.putAll(m2);System.out.println(m3);","link":"/2019/12/27/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9B%9E%E9%A1%BE/"},{"title":"回顾JDBC","text":"JDBC简介： 称为数据库连接纽带 如果说想要有一个程序实现数据库之间切换的方法，这个时候可以分层实现，但是实现的方式很不方便，解决方式有**ODBC和JDBC** 是Java访问数据库平台统一的接口； JDBC的结构java程序访问JDBC的一端是统一的而连接数据库的一端是不一样的，这个也是不同的数据库厂商实现的也需担心这个。 JDBC的编程步骤在这之前首先要把Oracle的驱动包给导入到项目中我的是Oracle12版本classes12.jar 导入方式–&gt;右键项目–&gt;Bulid Path–&gt;Add External Archives–找到你Oracle驱动包导入即可 1，Load the Driver告诉DriverManager和那个数据库连 新建一个Java程序（工具是Eclipse）名字为JDBC JDBC的所有的类库都在java.sql.*这个包下 新建一个Class名字为TestDML 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.sql.*;//import com.sun.tools.internal.xjc.model.Constructor;public class TestDML { public static void main(String[] args) { Connection con = null; Statement stat = null; ResultSet rs =null; try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); // 实例化OracleDriver 会自动向DriverManager注册加载数据库驱动 //new oracle.jdbc.driver.OracleDriver(); 这种方式和上面一样 System.out.println(&quot;数据库驱动加载成功！&quot;); // 输出的信息 String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user = &quot;c##scott&quot;; // 连接用户名 String password = &quot;tiger&quot;; // 连接密码 con = DriverManager.getConnection(url, user, password); // 获取数据库连接 if (con != null) { System.out.println(&quot;成功的与Oracle数据库建立连接！！&quot;); } stat = con.createStatement(); String sql = &quot;insert into dept2 values(98,'h','y')&quot;; stat.executeUpdate(sql); System.out.println(&quot;插入成功&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { try { if(rs != null) { rs.close(); rs = null; } if(stat != null) { stat.close(); stat=null; } if(con != null) { con.close(); con=null; } } catch (Exception e2) { e2.printStackTrace(); } } }} url中连接的ORCL是你Oracle数据库对外公开的服务名字如果不知道或者忘记了可以在Oracle客户端使用命令select global_name from global_name;来查看如下图所示 2，**JDBC**使用prepareStatement是Statement的实现类意味着有更多的实现方法代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.sql.*;//import com.sun.tools.internal.xjc.model.Constructor;public class TestDML2 { public static void main(String[] args) { int deptno = 0; try { deptno= Integer.parseInt(args[0]); } catch (Exception e) { System.out.println(&quot;Parameter Error ! Deptno should be Number Format!&quot;); System.exit(-1);//正常退出 } String dname = args[1]; String loc = args[2]; Connection con = null; Statement stat = null; ResultSet rs =null; PreparedStatement pstat = null; try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); // 实例化OracleDriver 会自动向DriverManager注册加载数据库驱动 //new oracle.jdbc.driver.OracleDriver(); 这种方式和上面一样 System.out.println(&quot;数据库驱动加载成功！&quot;); // 输出的信息 String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user = &quot;c##scott&quot;; // 连接用户名 String password = &quot;tiger&quot;; // 连接密码 con = DriverManager.getConnection(url, user, password); // 获取数据库连接 if (con != null) { System.out.println(&quot;成功的与Oracle数据库建立连接！！&quot;); } pstat = con.prepareStatement(&quot;insert into dept2 values(?, ?, ?)&quot;); pstat.setInt(1, deptno); pstat.setString(2, dname); pstat.setString(3, loc); pstat.executeUpdate(); System.out.println(&quot;插入成功&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { try { if(pstat != null) { pstat.close(); pstat=null; } if(con != null) { con.close(); con=null; } } catch (Exception e2) { e2.printStackTrace(); } } }} 3，**JDBC**处理存储过程代码 12345678910111213141516171819202122232425262728import java.sql.*;public class TestProc {//对存储过程进行调用 public static void main(String[] args) throws Exception { // Class.forName(&quot;oracle.jdbc.driver.OrecleDriver&quot;); Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user =&quot;c##scott&quot;; String password =&quot;tiger&quot;; Connection con = DriverManager.getConnection(url, user, password); System.out.println(&quot;加载数据库驱动成功&quot;); CallableStatement cs = con.prepareCall(&quot;{call p(?,?,?,?)}&quot;);//p是存储过程的名字后面是有几个参数就用几个占位符代替 cs.registerOutParameter(3, Types.INTEGER);//表示那个是输出参数,用Types来指定输出参数的类型 cs.registerOutParameter(4, Types.INTEGER); cs.setInt(1, 3); cs.setInt(2, 4); cs.setInt(4, 5); cs.execute(); System.out.println(cs.getInt(3));//把第三个参数的值当成INT类型拿出来 System.out.println(cs.getInt(4));//把第四个参数的值当成INT类型拿出来 cs.close(); con.close(); }} 3，**JDBC**处理批处理代码 大概意思就是可以多条数据一次性插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.sql.*;public class TestBatch { public static void main(String[] args) throws ClassNotFoundException, SQLException { Connection con= null; Statement stat = null; //Statement可以进行批处理 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user =&quot;c##scott&quot;; String password =&quot;tiger&quot;; con = DriverManager.getConnection(url, user, password); System.out.println(&quot;加载数据库驱动成功&quot;); stat= con.createStatement(); stat.addBatch(&quot;insert into dept2 values(51,'dan','henyan')&quot;); stat.addBatch(&quot;insert into dept2 values(52,'dan','henyan')&quot;); stat.addBatch(&quot;insert into dept2 values(53,'dan','henyan')&quot;); stat.executeBatch(); stat.close(); con.close(); /* PreparedStatement也可以进行批处理 PreparedStatement ps = con.prepareStatement(&quot;insert into dept2 values(?, ?, ?)&quot;); ps.setInt(1, 51); ps.setString(2, &quot;dna&quot;); ps.setString(3, &quot;heyan&quot;); ps.addBatch(); ps.setInt(1, 52); ps.setString(2, &quot;dan&quot;); ps.setString(3, &quot;henyan&quot;); ps.addBatch(); ps.setInt(1, 53); ps.setString(2, &quot;dan&quot;); ps.setString(3, &quot;henyan&quot;); ps.addBatch(); System.out.println(&quot;一次性提交成功&quot;); ps.executeBatch(); ps.close(); con.close(); */ }} 4，**JDBC**处理Transaction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.sql.*;public class TestTransaction { public static void main(String[] args) { Connection con= null; Statement stat = null; try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user =&quot;c##scott&quot;; String password =&quot;tiger&quot;; con = DriverManager.getConnection(url, user, password); System.out.println(&quot;加载数据库驱动成功&quot;); con.setAutoCommit(false);//第一步把setAutocommit设成FALse不让自动提交 stat = con.createStatement();//干自己的事 stat.addBatch(&quot;insert into dept2 values(54,'dan','henyan')&quot;); stat.addBatch(&quot;insert into dept2 values(55,'dna','henyan')&quot;); stat.addBatch(&quot;insert into dept2 values(56,'dna','henyan')&quot;); stat.executeBatch(); con.commit();//自己进行提交 con.setAutoCommit(true);//提交完成之后恢复现场把setAutoCommit设回成trye } catch (ClassNotFoundException e) { e.printStackTrace(); //捕捉到任何的SQLException要记得写rollback表示回退 }catch (SQLException e) { e.printStackTrace(); try { if(con!= null) { con.rollback(); con.setAutoCommit(true); } } catch (SQLException e1) { e1.printStackTrace(); } }finally { try { if(con!= null) { con.close(); con=null; } if(stat !=null) { stat.close(); stat = null; } } catch (SQLException e) { e.printStackTrace(); } } }} 5，**JDBC**处理可滚动的结果集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.sql.*;/* * JDBC处理可更新的结果集 */public class TestScroll { public static void main(String[] args) { Connection con = null; Statement stat= null; ResultSet rs =null; try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); // 加载数据库驱动 System.out.println(&quot;数据库驱动加载成功！&quot;); // 输出的信息 String url = &quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; // 获取连接URL String user = &quot;c##scott&quot;; // 连接用户名 String password = &quot;tiger&quot;; // 连接密码 con = DriverManager.getConnection(url, user, password); // 获取数据库连接 stat = con.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE,//表示对于滚动不敏感 ResultSet.CONCUR_READ_ONLY); rs = stat.executeQuery(&quot;select * from emp order by sal&quot;); rs.next(); System.out.println(rs.getInt(1));//也就是取出emp的第一个empno的字段 rs.last();//将光标移动到最后一行 System.out.println(rs.getString(1));//取出最后一行的empno字段 System.out.println(rs.isLast());//是不是最后一行 System.out.println(rs.isAfterLast()); System.out.println(rs.getRow());//显示当前是哪个字段 rs.previous(); //将光标移到该resultset对象的上一行 System.out.println(rs.getString(1)); rs.absolute(6); //定位到第六行上面 System.out.println(rs.getString(1)); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { try { if(rs!=null) { rs.close(); rs=null; } if(stat != null) { stat.close(); stat = null; } if(con!=null) { con.close(); con=null; } } catch (SQLException e) { e.printStackTrace(); } }}} 其他的知识 DataSource**和RowSet** DataSource是DriverManager的替代DataSource可以用作为连接池以及分布式的实现 RowSet 新的ResultSet从ResultSet接口继承比ResultSet更好用。支持断开的结果集，支持JavaBean标准 结束~~ 都是以前学过的代码温习一遍","link":"/2019/12/11/%E5%9B%9E%E9%A1%BEJDBC/"},{"title":"使用阿里云和宝塔搭建wordpress个人博客","text":"前言： 其实呢关于这个wordpress的博客搭建，网上呢一抓一大把的，我呢其实也不是特意来写的这个，只是因为我的服务器呢一直闲着，没事干，然后我还有一个域名还有一天过期，明天就过期了，于是就半夜安排一下子！ 不多说了直接开始教程吧 服务篇：一，你先要有一个服务器，笔者这里用的是阿里云，你用其他的也可以只说是后台的操作方式可能不太一样的，如果你是要新买服务器的话，那么系统可以选择是 CentOS 7.5 版本的，假如说你有了一个服务器的话，系统如果不是这个 CentOS 7.5 我们就需要更换服务器的系统，具体操作方式如下： 1，在阿里云要更换操作系统呢，我们需要先把这个实例服务器给停掉。如下图所示： 2，找到云盘和镜像，点击更换操作系统。如下图所示： 3，然后他会问你，是否给你的ECS更换操作系统，选择确定即可，然后找到公共镜像，选择我们的CentOS 7.5的版本，再选择自定义密码，设置好密码，勾上服务协议，然后确定订单即可 4，然后会弹出一个框，需要你手动输入我们的手机验证码，输入正确就完成了操作系统的更换了。如下图所示 点击控制台就可以了，你的实例会自动的重启。 配置安全组：1，接着我们需要配置我的实例安全组，这一步有点麻烦，慢慢看吧，这里就不截图了，你要先找到网络与安全，然后找到安全组—&gt;点击创建安全组，然后写上名字即可，点击创建 2，然后我们把这些配置规则设置成这个样子：(如果你觉得一个一个填的太麻烦了，这里下载就行了) https://ws28.cn/f/45mp9jzl3u0 如果失效了那么请评论留下你的联系方式 3，然后返回实例，把我们新增加的一个安全配置，给添加进去：找到网络和安全组 点击加入安全组 选择我们的刚刚的安全组，然后点击确定，如下图所示： 宝塔篇：1，找到宝塔官网：https://www.bt.cn/ ，选择Linux版，再选择立即安装 2，然后你会看到很多下载链接，笔者呢用的是江苏 的，把这个下载链接复制好，到你的阿里云服务器，笔者推荐使用Xshell比较安全可靠，目前也有个人免费版本 1yum install -y wget &amp;&amp; wget -O install.sh http://180.101.160.68:5880/install/install_6.0.sh &amp;&amp; sh install.sh 3，回车就开始安全，中间会问你是否yes，输入y就可以了 4，最后你会得到一个链接，这个链接就是我们宝塔后台的地址了，同时还会给你一个初始化的用户名和密码，如下图所示： 5，复制到我们的浏览器当中就访问这个后台了，首次进入可能有一个用户详情的一个东西，勾选上就行了，如下图： 6，然后会弹出一个框让你选择LNMP安装的软件，就按照这么选择就行了！,或者你去到我们WORDPRESS官网去看下它要求的相关配置，笔者也是看过了，所以就不多说了，直接一键安装就完事了！这个安装过有点久，去看下一步把！ 7，来到我们的wordpress官网：博客发布平台和内容管理系统 | WordPress.org China 简体中文 ，下载我们的压缩包，点击获取wordpress，这个压缩包是要上传到我们的宝塔后台的。 8，等我们的软件安装完成之后，然后再点击我们文件——上传文件需要上传刚刚下载wordpress的压缩文件 9，上传到宝塔里面然后解压到这个目录 10，然后点击后台的网站设置，点击添加站点 11，提交完成之后，会给你一个数据库的信息，这个要记得，有用的 12，到这里就差不多wordpress就是配置的差不多了,访问我们的刚刚的域名,如果你看到这个界面就代表你的wordpress配置的差不多了，就接着下一步的感觉就行了 13，配置数据库信息，这里就是你之前在添加网站之后会给你弹出一个框哪里的数据库信息，别写错了 14，就安装就完事了！ 15，再配置我们的wordpress网站的信息,根据喜好来！ 16，最后进入到登录界面， 17，点击检查站点就可以看到我们的博客主页面啦，如果你觉得这个主题不好看的话，也可以自己在后台进行切换的啦 总结： 整个过程虽然是没有什么太麻烦的地方，但是步骤确实有点繁琐，好在最后大功告成！，如果你觉得写的还不错，那就多看几眼🤭。","link":"/2020/12/06/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%92%8C%E5%AE%9D%E5%A1%94%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"关于18岁的那一份答卷","text":"​ 关于这一天我想了很多很久 我想过我自己会有能力我想过我想过我生日应该怎么过，或者是和好朋友一起过，当然了最重要的是和自己喜欢的人一起过了想过会去哪里玩会去哪里吃饭会有太多太多想过了； 但是怎么也没想过在生日的前一天晚上我会流下这不争气的眼泪或许是因为自己在怪自己没有能力，也许是怪自己没有达到自己想象的预期效果，也许是一下子接受不了这样子的挫折感，或许是这强大的野心我还配不上，我和自己喜欢的人说了句我想自己待会，其实那只是我在逃避，妈在那个时候打了个电话和我说：你明天生日啊，我：不晓得啊，其实有时候我就是怕这一下突然的关心，总觉得我没有长大，当孩子都想当父母的骄傲，当时的我实在是说不话来想到自己还没那个能力还没达到自己的预期，只能回答，好咯，嗯，挂了咯。 ​ 回想这18年 从初中什么都不知道到技校的几个朋友到异地的感受到生活不容易到现在的感概，以前总觉得自己有多么的厉害，到了后面才知道自己其实是个菜鸟，也许只是个平凡人，也没什么太多的不一样，也和大多数人一样，有时候不想表现得多么矫情，自己的故事没和太多人分享大多数时候自己是个聆听者，有时候别人的故事很精彩，更多时候自己是个话题开头者，这可能是因为身边的人只要我一开口他们就会说个不停的原因。记得初中那会，班主任说我不成熟装成熟，那时候对成熟也没多大的概念，只是突然觉得自己好像也要懂得点什么，当然了这句话影响了我很久，后来把初二下学期的时候就没有在他手里读了，那时候整天也没什么事，说是会检查作业就抄作业，上课会睡觉，每次考试都是那么平衡，就那样整个初中生涯就结束了那时候别人都说别差个一分两分什么的，我当时还觉得这种事情和我肯定是没有什么关系的了考不上就考不上了吧，谁知道我的分数就隔了两分，也许是老天开玩笑呢，还是命运是如此当时自己还偷偷的哭了一会，那时候就觉得自己这个人真的不懂事， 再后来因为家里原因我爸妈不怎么管我，直到开学前几天才给我随便找了个学校，也没想太多就进去了，随便的学校当然很随便了，哪里除了认识几个很好的朋友除外，可能就是上课睡觉和打球了，再后来我就说我不想读了，我想出去找份工作，赚钱吧，以为一年两年可以自己有点小积蓄了，那时候也太天真了，我爸给我找了份手艺活，也就是做学徒，学了半年我回来了，可能是坚持不来，可能是因为还小，我爸说我没有毅力，更多的原因是因为我不想这么一辈子，我走的那天我爸没有来送我让我一个人回去了，我还记得我走的时候一个人去车站，走之前含泪给我爸发了一段很长的文字，给他道歉。回到老地方后面找了一个学电脑的地方。总是要学一点东西的于是就去了，其实大部分东西都是自己学的，在这里没有学到太多的东西，以及好朋友都没有几个可能也是因为自己不太愿意交心的原因。 也就这个时候我可能遇见了我生命中的那个她。没有什么前提 可能这也是命运，我是个无神论者，从不相信什么佛邪教什么的，但是她就那样出现在了我生命中，还记得和他遇见的时候是因为她喜欢她们学校另外一个男生，向我请教如何是好，后面（我属实有些不耐烦）的回复她。后面那个男生好像不领情，美妙的事情就发生在了我们身上。在一起一年多了；在这里要和你说一句谢谢，谢谢你包容我的以前不懂事，谢谢你包容我的犯的错误，谢谢你教会我很多东西， 对你的感觉从美妙到心动到那种说不上的熟悉。说实话第一次和你见面我实在没准备好，很多东西可能还不会，就像你说的连花都没买，哈哈，我不是故事的。我现在很期待我们下次一见面我总觉得我们很快就会再一次见面 哈哈，我们之间的故事可能也许别人都不会懂，但这是属于我们的故事，我希望这是我这辈子最值得回忆的一件事，你总是不好好照顾自己，这不 又给我感冒了，体制不是很好还总是让人担心，爱哭鬼，总是受到委屈就会想要哭，每次遇到冷战时就会委屈的不行，其实这种话对你说过不少，但是还是忍不住对你得描述哪怕是写满都不够的，（其实我手很疼了很累了）于是今天这平凡的一天就这么过去了，我也意识到自己也是个平凡人。自己可以慢慢的接受也要学会接受，学会一点一点长大，写到了这里又想起了那句话，我很欣赏你，但不一定成为你，我转过身，安静的做我自己。 最后： 后海有树的院子 夏待有工的玉 此时此刻的云 18岁的你 人总要学着长大，愿我一如既往还是少年样；","link":"/2019/10/18/%E5%85%B3%E4%BA%8E18%E5%B2%81%E7%9A%84%E9%82%A3%E4%B8%80%E4%BB%BD%E7%AD%94%E5%8D%B7/"},{"title":"如何访问同一局域网内的虚拟机","text":"前言：你在自己的台式机或笔记本中使用VMware Workstation搭建了一个虚拟机系统，如Debian、Ubuntu等Linux系统。现在你希望使用局域网中另一台电脑访问你电脑上的虚拟机系统，怎么办呢 前提： 这是使用的VMware 15 Pro提供的NAT功能，推荐新版。 两台电脑，一台装了linux系统 操作步骤1， 首先设置VMware的虚拟机网络配置是NAT。找到菜单栏虚拟机–设置 2，打开虚拟机点击编辑–&gt; 虚拟机网络编辑器–&gt;以管理员运行 3，查看虚拟机IP 4，找到端口转发--&gt; 添加，显示如下图 在弹出的框中依次添加： 主机端口：推荐1024到4999 虚拟机IP：就是上面查到的虚拟机IP地址 虚拟机端口：（如果是SSH连接，使用 22 端口，如果是WEB 程序访问，推荐设置为80,具体要求根据自己的情况来定） 描述：可选（可以写可以不写） 最后点击–&gt;确定–&gt;应用 ，等到VMware初始化网络设置生效 宿主机设置： 1，共享VMnet8。2，找到网络连接的控制面板 3，右键属性 勾选上Internet连接共享 家庭网络连接里选择虚拟机VMnet8那个网络连接如果没有就选择VMent1网络 使用SSH登陆：1，连接之前我们需要看一下宿主机的IP地址，注意这里不是虚拟的IP，而是宿主机的IP使用Ipconfig命令来查询，比如我的是192.168.43.63 2，这里使用的是Xshell 个人版，当然用其他的连接工具同样可以，–&gt;新建一个连接 3，第一次登陆的话，会让你保存一些证书，以及要输入登陆的用户名和密码，勾选上记住用户名下次就不用再输入了 问题：SSH访问超时，无法连接 解决方法： 首先，保证虚拟机系统是开机状态； 其次，关闭防火墙（专业网络和来宾或公用网络），尝试连接。 关闭防火墙并不妥，推荐在【Windows防火墙】的【高级设置】中添加入站规则，运行前面设置的TCP端口连接。 安装 oh my zsh 官网地址：https://ohmyz.sh/ 注意：如果使用官网提供的命令下载可能会提示你：curl: (7) Failed to connect to raw.github.com port 443: Connecti 所以改为使用如下命令： 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 1，安装成功后：(命令行变得简直不要太好看~，除此之外官网还提供了其他许多主题 https://github.com/ohmyzsh/ohmyzsh/wiki/Themes) 2，如果想改主题，安装完oh my zsh 之后在本地主目录会生成一个.zshrc的文件 使用命令： 1vi .zshrc 3，修改里面的内容：ZSH_THEME=&quot;你喜欢的主题名字&quot;。 比如： 1ZSH_THEME=&quot;muse&quot; 4，使用source 让配置生效： 1source .zshrc 执行完成后，就会发现，主题已经变了。 END 参考： https://blog.csdn.net/u012268339/article/details/61204801 https://www.jianshu.com/p/db488f0ae3c0 https://www.jianshu.com/p/665ca10a0f5a","link":"/2020/04/17/%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"学习POI","text":"前言：除了使用Apache POI操作Excel还有JXL也可以对Excel进行操作，关于JXL的说明官网有更加详细的介绍:http://jexcelapi.sourceforge.net/ ；好像是停止维护了？ 这个是Apache POI的官网 ：http://poi.apache.org/ Excel的两种形式在Excel2003是一个特c有的二进制格式，其核心结构是复合文档类型的结构，存储数据量较小；后缀是：xls 存储容量有限； 而Excel2007核心结构是XML类型的结构，采用的是基于XML的压缩方式，使其占用空间更小，操作效率更高 后缀是：xlsx 可以存储的数据比较多； POI结构说明HSSF提供读写Microsoft Excel XLS格式档案的功能。 XSSF提供读写Microsoft Excel OOXML XLSX格式档案的功能。 HWPF提供读写Microsoft Word DOC格式档案的功能。 HSLF提供读写Microsoft PowerPoint格式档案的功能。 HDGF提供读Microsoft Visio格式档案的功能。 HPBF提供读Microsoft Publisher格式档案的功能。 HSMF提供读Microsoft Outlook格式档案的功能。 API说明 API名称 Workbook Excel的文档对象，针对不同的Excel类型分为：HSSFWorkbook（2003）和XSSFWorkbool(2007) Sheet Excel的表单 Row Excel的行 Cell Excel的格子单元 Font Excel字体 CellStyle 格子单元样式 使用步骤：导入相关依赖： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 从版本4.0.1开始，POI需要java8或更高的版本 可以先编写一个创建Excel文件的测试程序：代码如下 文件流的目录位置不一定是我的这个目录位置可以自己改变 1234567891011121314151617181920212223242526272829package cn.itcast.poi.test;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;/** * 使用POI创建excel */public class PoiTest01 { public static void main(String[] args) throws Exception { //1.创建工作簿 Workbook wb = new XSSFWorkbook(); // 2007版本 //2.创建表单sheet Sheet test = wb.createSheet(&quot;test&quot;); //3.文件流 FileOutputStream pis = new FileOutputStream(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\test.xlsx&quot;); //4.写入文件 wb.write(pis); pis.close(); }} 测试成功后可以看到这个目录下有一个test.xlsx文件 我们可以试着写入一点单元格内容进去：row.createCell(2) 表示的是从索引下标为2的位置开始插入数据。下面运行成功之后会看到下标为2的位置和下标为3的位置都有内容 1234567891011121314151617181920212223242526272829303132333435363738package cn.itcast.poi.test;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileOutputStream;/** * 使用POI创建excel */public class PoiTest02 { public static void main(String[] args) throws Exception { //1.创建工作簿 Workbook wb = new XSSFWorkbook(); // 2007版本 //2.创建表单sheet Sheet sheet = wb.createSheet(&quot;test&quot;); //创建行对象 参数：根据索引从0开始 Row row = sheet.createRow(2); //创建单元格对象 参数：根据索引从0开始 Cell cell = row.createCell(2); //向单元格中输入内容 cell.setCellValue(&quot;上天入地&quot;); Cell cell1 = row.createCell(3); cell1.setCellValue(&quot;泪目&quot;); //3.文件流 FileOutputStream pis = new FileOutputStream(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\test1.xlsx&quot;); //4.写入文件 wb.write(pis); pis.close(); }} Excel中修改字体的样式属性代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.itcast.poi.test;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileOutputStream;/** * 使用POI创建excel */public class PoiTest03 { public static void main(String[] args) throws Exception { //1.创建工作簿 Workbook wb = new XSSFWorkbook(); // 2007版本 //2.创建表单sheet Sheet sheet = wb.createSheet(&quot;test&quot;); //创建行对象 参数：根据索引从0开始 Row row = sheet.createRow(2); //创建单元格对象 参数：根据索引从0开始 Cell cell = row.createCell(2); //向单元格中输入内容 cell.setCellValue(&quot;天天向上&quot;); Cell cell1 = row.createCell(3); cell1.setCellValue(&quot;泪目&quot;); //编写单元格的样式 CellStyle style = wb.createCellStyle(); style.setBorderTop(BorderStyle.THIN); // 设置上边框 style.setBorderBottom(BorderStyle.THIN); style.setBorderLeft(BorderStyle.THIN); style.setBorderRight(BorderStyle.THIN); //创建字体对象 Font font = wb.createFont(); font.setFontName(&quot;微软雅黑&quot;); // 设置字体的字体样式 font.setFontHeightInPoints((short) 28); // 设置字号 style.setFont(font); //设置行高和列宽 row.setHeightInPoints(50); // 行高 //列宽的宽度 字符宽度 sheet.setColumnWidth(2,31 * 256); //居中显示 style.setAlignment(HorizontalAlignment.CENTER); //水平居中 style.setVerticalAlignment(VerticalAlignment.CENTER); // 垂直居中 //把样式设置到单元格里 cell.setCellStyle(style); //3.文件流 FileOutputStream pis = new FileOutputStream(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\test3.xlsx&quot;); //4.写入文件 wb.write(pis); pis.close(); }} 绘制图片到Excel中首先准备一张图片放到一个目录下使用FileInputStream读取这个文件流转换成二进制数组使用图片的工具类绘制一个图片对象最后绘制自适应图片 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.poi.test;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.usermodel.*;import org.apache.poi.util.IOUtils;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileInputStream;import java.io.FileOutputStream;/** * 使用POI创建excel */public class PoiTest04 { public static void main(String[] args) throws Exception { //1.创建工作簿 Workbook wb = new XSSFWorkbook(); // 2007版本 //2.创建表单sheet Sheet sheet = wb.createSheet(&quot;test&quot;); //读取图片流 FileInputStream stream = new FileInputStream(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\logo.jpg&quot;); //转化二进制数组 byte[] bytes = IOUtils.toByteArray(stream); stream.read(bytes); //向poi内存中添加一张图片，返回图片在突图片集合中的索引 int index = wb.addPicture(bytes, Workbook.PICTURE_TYPE_JPEG); // 参数一 图片的二进制数据 参数二 图片的类型 //创建一个图片工具类 CreationHelper helper = wb.getCreationHelper(); //创建一个绘图对象 Drawing&lt;?&gt; patriarch = sheet.createDrawingPatriarch(); //创建锚点，设置图片坐标 ClientAnchor anchor = helper.createClientAnchor(); anchor.setRow1(0); //从第0行 anchor.setCol1(0); //从第0个单元格 //绘制图片 Picture picture = patriarch.createPicture(anchor, index);//图片位置，图片的索引 picture.resize(); //渲染图片自适应 //3.文件流 FileOutputStream pis = new FileOutputStream(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\test3.xlsx&quot;); //4.写入文件 wb.write(pis); pis.close(); }} 解析(获取)Excel中的内容你有一个excel文件里面有一些数据，想要获取这里面的数据 序号 姓名 年龄 家庭住址 出生日期 1 张三 18 北京 2001/11/1 2 李四 20 上海 2001/11/1 3 王五 18 广州 2001/11/1 4 赵六 20 深圳 2001/11/1 代码如下： 在获取单元格的时候我们需要判断单元格的类型，根据不同类型获取不同类型的数据，在判断NUMERIC类型的时候需要判断是日期类型还是数字类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package cn.itcast.poi.test;import org.apache.poi.ss.usermodel.*;import org.apache.poi.util.IOUtils;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileInputStream;import java.io.FileOutputStream;/** * 使用POI创建excel * sheet.getLastRowNum() // 最后一行的索引 * row.getLastCellNum() // 最后一个单元格的号码 */public class PoiTest05 { public static void main(String[] args) throws Exception { //1。根据Excel文件创建工作簿 Workbook wb = new XSSFWorkbook(&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\Excel\\\\demo.xlsx&quot;); //2。获取sheet Sheet sheet = wb.getSheetAt(0);//参数 索引 //2.获取Sheet中的每一行。和每一个单元格 for (int rowNum = 0; rowNum &lt;= sheet.getLastRowNum(); rowNum++){ Row row = sheet.getRow(rowNum); //根据索引获取每一行 StringBuffer stringBuffer = new StringBuffer(); for (int cellNum =2;cellNum &lt; row.getLastCellNum(); cellNum++){ //根据索引获取每一个单元格 Cell cell = row.getCell(cellNum); //获取每一个单元格的内容 Object value = getCellValue(cell); stringBuffer.append(value).append(&quot;-&quot;); } System.out.println(stringBuffer.toString()); } } public static Object getCellValue(Cell cell){ //根据单元格的类型判断不同的 CellType cellType = cell.getCellType(); //根据单元格数据类型获取数据 Object value = null; switch (cellType){ case STRING: value = cell.getStringCellValue(); break; case BOOLEAN: value = cell.getBooleanCellValue(); break; case NUMERIC: if(DateUtil.isCellDateFormatted(cell)){ value = cell.getDateCellValue(); // 日期格式 }else { value = cell.getNumericCellValue(); // 数字格式 } break; case FORMULA: value = cell.getCellFormula(); // 公式 default: break; } return value; }}","link":"/2020/01/27/%E5%AD%A6%E4%B9%A0POI/"},{"title":"反思","text":"7a38937753c6dd18e5cb7e2ae1b0e98913116bbacd6a524f9b6544a113cf571702d1a8724af4123a682a39f5a0af565cb88ce8a21353b748443e10eec5a545bca4d264ae678860c7cb1ecf7dd468e0292f03719497bf2ce84a367a6e4d6cb429a78cfe19f0492ef7ee381ecd085f9d38a7946e8ae75c497377a334195d3ee48d14ef8002945cba2a5602d368f1a5d28286889aca48ac2c786a691ebc369def9595b0841379287a49725b338d0fee86d7bc5c806aeb3bf2c27ef64d4b89c47e362f48891efea892926abf9c6c452c453aaed6f47dac74759a75fa9ff37adea890387ac3fc742cf611a2edf9550c1f2aa8c534d646a6348b7aa1360cb4b028bea4454f91a52e0fe5452360be02178b520d1a0883bf1529d0af3473e638e74be2a1dce8d84cbd864cc6ac1e0894d4cc79a6e1a2f325f4dce5d50ad903112ba8b4678661d74ab65cf3a2171c652e8efdb1da3a50d8ac7e2a75d1a0a76aee6ea636934173f1dc627ddd37df178d1ba746d663840cb7eeea0886565589606ea14469f405a85cb0fbcd73e6a688df90c71e579e4dc065a632fcec54b6d62b425ec8d2608500af86574b91c1b15e98a2ad5206a013fd69566c425c4824c254e032583e01d9880a23a9c38e5ad510e07980dd9814d1d3290c1ed1b19ba91a830a26191dd79452a0bfdea8b36b3760717dd25f21fd4ce43ef961fc01d9825a67c78377b292eb7630e252960e1638efd18a01da3d3cd50fc8784f2691d53373f26267ae3b4687eb79273b5e3750bc7b760a04a1492646b8359f6bc172bb4956e40ab4d2a275eac43898f3002ec8d0811efe9fe2e4883cc2bf10404b84157797edb867ab3c2edc414847fcc514599c92df5ea1b430fcc03bd77447f0223640175b098bbcc5ab74f8ef6d07883c814ceab3b53a9a47c83462e30a0e3ac60f8c78d92f4fc81d845223b993174c21b37285395ea37dd643219822f5eebfba84d6d60faf8c0ca9ab0d69caf18749bd687a385a4f8b342310fe0b91da22c361134f0055e5674ed2aa6d2541e0ad876513f81d2a545c9e602ee384dece4e99ac425beff76cf64abccf962c415835b7cb267047242202d1646f3b0cc74c8166be771bab6493ac6e4cdf84b5b4f9df2e77c4dee712a5e0bbe0c786709c306e8f41a83b730d20062f72e3e5756e898df295b521d6d1e0a159b8b7d779f26fc22e80e50847a4179180a5d6a136346252d6ca0702772477dcbc3cb130432814b0b4434c39572db2bbd6910e247cddcfe41844b89659e11a3fb1a1b519240092b7de15a5add052f7aa830020eede8fe47e19b02996e3cb029b37bf6534df76dfc0fcef2e7dd8b7bee032ce83291c1d3b76a028bc836764b840cf693f90eeb3b96c3c5e3274fd4a8daeb86fd8cc1a5645fc565cf1a44f2f2dbcf65ea04ec71bb3e0441ab12096c407e47a0e4f062f2c8fd3e4b79e6d41222984b21e997d10eff93e8cffae84fcbab96a56cbfaa421d107ba173aaad746f032d9523c6bc15ea05f22f000bde54c47c11d1e98a3d9de783ba6ddb07d91879cb031e0724e7111396a2b0e32729c096693886ce748068fe2a91bbfec5f82064f546f94183cbb468cb1ee7c2d890ef784ba83135fd2f700746f19f208656eb093136b6855b4ccb8e61ec40763ecc07986c4996b64dce70b671953e9e03489995f7f2180cbd14d24bfc8e3c5112fa7bb4ab89579e2a93bd2cb49175033db3acae7eca04dc7e62f98089859536b535426c22d4f070b136d05d86bde07213f9a20a247a0a87c862eb758126cbb4d52f436c80a16308203a8d4e230b0456c7590f67473f6d4e347cd453edd702eb5a22970e56e7b0a40f605cbf56c7aebcb1a3613ba285d0af14231f84db7b39c947ed2eee73639f22d097d601d92b33bcb9b8903d7ebe24a8f47b5cf143b6ebcf49cc737aad47a4a365e946bab080fa1516f0ddcccf6b829caa18985b85957f33976fe4cdec365c9c69a6d69667575734c37a8f4a6cb16c9074525b75cb0e12a68fcde9f61b87bfdeafbad837ebb90750e6bbf814613bcdf791d5f0fd51a85410fb39f57a5ec3b58465e330ec06cd775702290669273f3eefb2f51efb2624406ab643c6563e00fb88c0a5d6f576645e86fca7ff82fbb6c8dd6498f464099c6ba8108f0cee712a98e1b1d5e20a3624c250aa7f6bd67057f1947486ea8091540b17ed0f8faf333a8efab13adb474704558d9c8ec24af6c0a3623bb1253a2fd338b3ac4bc01fb4e0205ac21fadc5fffecf36b90ce46354a6680fbf4e32ab9ed330de4cea8a5c99b3ecdd289ed900af73a896087f020bb8abe7e5d64d932ec8116f549c0875263ab26f9ea5073fc47ebb5c4792d9f1b3f5882a40414cbc9de892925e7cb9cec1ad23e87bd8dc664b900437a38301abb5ba99a09dc3acfeba510614ea56491fdacd00a81fa49f51de0a56d747884aa36e56684a712c93c77bd6648f2074a8a07f605695482ff6d04c6d43634237e5e98d88b51f46af308d9458c165bf2d06a00510a8ced0b55c3cf265ce0efccb5cfe3931ea6d195556a432b3b55700779f604b21c931246afadfa64d3d602c65aaebf27cf7f4d937659b8148e75629ffcd29b162e96241a4a67955b401b98375a6057b5988d8faa47a3a038ad7c8fca6270941877f50c4fbc20735c2d278d1096f02aca39b3b515056900fe1f333e9e8e60e701244dcc01fdf47c3829f2eda9b649a1985a689a0f55cb86c919a2e32004dbe37b69f421ca34d5f66f6759a653d8e944d14afc08c1f71db26d75440916fd424ea38e0794658ef886dbf803b4264c153f8d6a95ef0e51df5652d46da8f5905b186e2a78a2dd211fde0d4cd585e801ab30e6f900a44be2f0f645e6bd7bc9596b682e097e3817f8af8c84d2e12e3648f1fc63fe2976f4100c4dac6764ed56884b0cd068f084a54292e2052fc5c552c88c5807d4ef8632af9f5ca506146290a7bead79bd93792791e7c641f728c75bb24c27cece964b710dff247598454d3ddfd21d6c9f6c60b4751eaf5b1c674639b8874fc125e5c1b1e5efb190c6ebaf2edccaa607a9dd6daf577af0c97ae2e1a49f96468656da128821a56eee34e19c683bc743b0fd1eb6066ecf920e18816236ce2b3d259ded76aff4fa340b3e1d14b07ef18aadac4dd907141229468338a0d5b6566d5c096b6cfa7d5f2e3b319e24defc3a878a307e5c41a9 嗨，请准确无误地输入密码查看哟！","link":"/2020/11/06/%E5%B9%B3%E5%B9%B3%E6%97%A0%E5%A5%87%E7%9A%84%E4%B8%80%E6%9D%AF%E5%A5%B6%E8%8C%B6%E9%92%B1/"},{"title":"完整的项目部署发布篇","text":"前言：学习前面的Ddocker-compose 部署各种服务，都是为了这一步作为铺垫，搭建部署了自己的GiTLab，以及自己nexus，还有自己的Harbor，关于这三个的服务的介绍这里不做过多的赘述，这里大致说一下部署的流程： 第一步： 我们去到自己的搭建的GitLab拉取全部代码 1git clone ..... 第二步： 把自己的代码打包全部上传到nexus 1mvn clean deploy -Dmaven.test.skip=true 第三步 一次构建到处运行： 部署到Harbor 更多服务详细信息参考：https://hub.docker.com/ 操作步骤1，新建一个文件夹为myshop 叫其他名字都可以，把打包好的代码压缩包，上传到这个文件夹下面 2，在这个文件夹下面定制镜像： 1root@ubuntu:/usr/local/docker/myshop# vi Dockerfile 内容为： 12345678910111213FROM tomcat:9.0-jre8 //这是tomcat的版本RUN rm -fr /usr/local/tomcat/webapps/ROOT/*COPY my-shop-web-admin-1.0.0-SNAPSHOT.zip /usr/local/tomcat/webapps/ROOTWORKDIR /usr/local/tomcat/webapps/ROOTRUN unzip my-shop-web-admin-1.0.0-SNAPSHOT.zip \\ &amp;&amp; rm -fr my-shop-web-admin-1.0.0-SNAPSHOT.zipWORKDIR /usr/local/tomcatEXPOSE 8080 3，构建Dockerfile：如果没有tomcat的镜像的话会帮你自动下载一个镜像 1root@ubuntu:/usr/local/docker/myshop# docker build -t mashop-admin . 4，然后使用Dokcer images，会看到有一个myshop-admin的镜像，新建一个docker-compose.yml文件启动这个镜像 1234567version: '3.1'services: myshop-admin: image: myshop-admin container_name: myshop-admin ports: - 8088:8080 这个时候如果数据库不是安装在同一台linux机器上面的话，需要去把数据库的镜像给启动起来，还有就是项目连接的是mysql的数据库，连接的url千万不要写错了，不然重新构建有一点麻烦的，**这一点千万要注意**。 5，然后启动这个docker-compose： 1docker-compose up -d 6，观察日志：看控制台有没有报错，如果有报错的地方都会在日志中显示出来，方便找出问题 1docker-compose logs -f 7，报错的话，可以先dow掉，然后再来 1docker-compose down 如果存在虚悬镜像，可以删除虚悬镜像：docker image prune 访问： http://192.168.199.xxx:8088/ 你的inux机器的ip地址加上8088即可看到项目页面 把镜像push到Harbor1，标记这个镜像： 1docker tag myshop-admin 192.168.199.148/myshop/admin 查看镜像docker images，你会看到有一个带着端口的myshop/admin 2，上传到私服 1docker push 192.168.199.148/myshop/admin 不同的linux环境下运行： 在不同的linux机器上面部署运行 1，配置docker客户端 1root@deployment:/usr/local/docker/myshop# vi /etc/docker/daemon.json 2，添加一点内容： 1234567{ &quot;registry-mirrors&quot;:[&quot;https://zyw2lmzb.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;:[ &quot;192.168.199.148&quot; //这是Harbor部署的ip地址 ]} 3，配置完这个，需要重启docker 1root@deployment:/usr/local/docker/myshop# systemctl restart docker拉取 4，我们先登陆 1root@deployment:/usr/local/docker/myshop# docker login 192.168.199.148 -u admin -p Harbor12345 5，然后拉取这个镜像： 1root@deployment:/usr/local/docker/myshop# docker pull 192.168.199.148/myshop/admin 6，新建一个docker-compose.yml：这里的镜像名稍微有点区别，可以使用dokcer images 查看镜像的名字 1234567version: '3.1'services: myshop-admin: image: 192.168.199.148/myshop/admin container_name: myshop-admin ports: - 8088:8080 7，运行这个镜像： 1root@deployment:/usr/local/docker/myshop# docker-compose up -d 访问： http://192.168.199.xxx:8088/login 你的linux机器的ip地址加上8088即可看到项目页面 通过服务名部署项目 以上都是测试环境所实验的结果，在实际部署的时候我们的数据库不应该被外部的数据库连接工具连接到，但是可以在同一局域网内被tomcat可以访问到； 我们在之前的测试过程中，我不小心把数据库的连接地址写错了，这样的方式很容易出错，也就是很不靠谱，我们需要把连接IP地址换成我们的服务名，这样显得更加的安全。 1，让tomcat和mysql在同一个局域网内，以便我们使用主机名（服务名），来进行访问 查看docker 默认的 网络 1root@deployment:/usr/local/docker/myshop# docker network ls 2，细心可以发现在启动mysql的时候，会输出这么一句话，也就是容器都有自己网络，不是在同一个局域网之中的。当然如果你启动tomcat同样也会创建一个tomcat的网络 3，如果是在同一个compose 里面，当然可以通过服务名来进行访问，我们需要把不同的compose 在相同的局域网内 4，我们可以创建一个myshop_network网络：让Compose 加入这个新创建的网络，让所有的Compose可以通信，查看网络就可以看到多了一个 myshop_network 的网络 1root@deployment:/usr/local/docker/myshop# docker network create myshop_network 5，配置mysql的 docker-compose 文件： 1234networks: default: external: name: myshop_network 6，配置 myshop（项目名字）的docker-compose 文件 1234networks: default: external: name: myshop_network 7，再次启动项目就不会去创建自己默认的网络了，然后修改mysql的docker-compose 文件，把端口号删掉，这样公网就访问不到mysql 了，基于docker隔离机制。 8，这个时候我们就可以基于服务名去访问，比如我的mysql服务名就是db，在项目的数据库连接配置文件当中连接IP地址改为db 即可，再次打包进行上传到我们myshop文件夹下。 9，重新构建：这里带了IP这样就不用再次去标记了 1root@ubuntu:/usr/local/docker/myshop# docker build -t 192.168.199.148/myshop/admin . 10，然后再上传到私服： 12345678910111213141516171819root@ubuntu:/usr/local/docker/myshop# docker push 192.168.199.148/myshop/admin#输出如下The push refers to repository [192.168.199.148/myshop/admin]2ce04fb23096: Layer already exists 235969d4ed49: Layer already exists 93b9e711a12d: Layer already exists aa6264ff0dcd: Layer already exists 2e33d763e75d: Layer already exists f0e1731fd286: Layer already exists 2b6c38ff3137: Layer already exists d38f3d5a39fb: Layer already exists fe60061c6c4e: Layer already exists 7d63f8777ebf: Layer already exists 1b958b53b256: Layer already exists 2c719774c1e1: Layer already exists ec62f19bb3aa: Layer already exists f94641f1fe1f: Layer already exists latest: digest: sha256:11db132f41eff185ef6b9ca9b85c507337cd0f2aed209038339562396e7dafb8 size: 3257 11，这个时候就可以去另外一个机器上把最新的镜像给pull下来： 1root@deployment:/usr/local/docker/myshop# docker pull 192.168.199.148/myshop/admin 12，最后启动即可： 1root@deployment:/usr/local/docker/myshop# docker-compose up -d 这样就完成了在不同的容器中，各自都实现了各自的局域网，以上就避免了把所有的端口暴露在了公网，这样极其不安全。这只是上生产的时候要注意的，开发中是不必要这样做的。 查看项目的配置文件改掉了没： 1root@deployment:/usr/local/docker/myshop# docker exec -it myshop-admin /bin/bash 然后去到webapps–&gt;ROOT–&gt;找到项目的数据库配置文件 cat 一下 即可看到内容 原则：实际项目部署的时候只有一个东西对外提供服务 END 到此项目的部署完成 最后要说的是，虽然部署过程不是太复杂，但是还是需要细心，在连接数据库的url地址上我花了好几个小时的时候，最后的原因是因为，密码写错了。这是个低级的不能再低级的错误了","link":"/2020/04/08/%E5%AE%8C%E6%95%B4%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E7%AF%87/"},{"title":"百度云人脸识别","text":"前言：百度云AI实际上也是基于人工智能的领域，人工智能（Artificial Intelligence）简称为AI。人工智能也是计算机科学的一个分支，用于研究，开发用于模拟，延伸和扩展人的智能的理论，方法，技术及应用系统的一门新的技术科学 人工智能包括很多应用领域智能家电，穿戴设备，智能机器人，人工智能技术已经进入到生活的各个领域，引发越来越多的关注 百度云AI概述官网地址：https://cloud.baidu.com/ 百度智能云是由百度创建并运营，提供云计算的服务的网站，创立于2015年。 百度人脸识别基于深度学习的人脸识别方案，准确识别图片中的人脸信息，提供如下功能： 1，人脸检测：快速检测人脸并返回人脸框位置，输出人脸150个关键点坐标，准确识别多种属性信息 2，人脸对比：两张人脸进行 1：1 比对，得到人脸相似度 3，人脸搜索：给定一张照片，对比人脸库中N张人脸，进行1：N搜索或者M：N搜索，返回搜索到的人脸以及对应的相似度 4，人脸库管理：人脸库管理接口组，包含人脸注册、删除、更新等11个接口 百度云AI的开发步骤1.首先得注册一个帐号然后创建应用（这一步是需要实名认证的）2.搭建工程导入相关依赖3.人脸注册4.人脸识别 注册与认证1），如果没有帐号的话，可以注册一个帐号：打开百度云注册官网：https://login.bce.baidu.com/reg.html?tpl=bceplat&amp;from=portal 进行帐号注册，（如果有百度帐号就不需要注册了可以直接使用百度的帐号进行登录） 2），创建应用：找到产品–&gt;人工智能–&gt;人脸识别激活应用，并且注册应用。 2.1)，进来之后你会看到一个控制台找到创建应用按钮创建一个应用，输入应用名称，选择类型，最后的描述可以随意写一点，最后点击立即创建即可 3)，创建完成后点击管理应用按钮，需要把AppID，API Key以及Secret Key这三个属性值全部复制下来后面会用到 搭建工程1），新建一个项目 2），导入依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;com.baidu.aip&lt;/groupId&gt; &lt;artifactId&gt;java-sdk&lt;/artifactId&gt; &lt;version&gt;4.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; s&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写一个Junit测试类，在init方法中的三个参数是前面复制的三个参数依次填入即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package cn.itcast.test;import com.baidu.aip.face.AipFace;import com.baidu.aip.util.Base64Util;import org.json.JSONObject;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.HashMap;public class FaceTest { private AipFace client; @Before public void init(){ //1.创建java代码和百度云交互的client对象 client = new AipFace(&quot;AppID&quot;,&quot;API Key&quot;,&quot;Secret Key&quot;); } //人脸注册 @Test public void testFaceRegister() throws IOException { //2.参数设置 HashMap&lt;String,String &gt; options = new HashMap&lt;String, String&gt;(); options.put(&quot;quality_control&quot;,&quot;NORMAL&quot;); //图片的质量 NONE LOW WORMAL HIGH options.put(&quot;liveness_control&quot;,&quot;LOW&quot;); //活体检测 //3.构造图片 String path =&quot;D:\\\\saas\\\\10-刷脸登录\\\\资源\\\\照片\\\\002.png&quot;; //上传图片有两种格式：一种是url另外一种是Beans64位的 byte[] bytes = Files.readAllBytes(Paths.get(path)); String encode = Base64Util.encode(bytes); //4。调用API方法完成人脸注册 /** * 参数一：是图片的url或者图片的base64 * 参数二：代表的是图片的形式 一种叫做url另外一种叫做beans64 * 参数三：组ID（固定字符串） * 参数四：用户id * 参数五：hashmap中的基本参数配置 */ JSONObject jsonObject = client.addUser(encode, &quot;BASE64&quot;, &quot;itcast&quot;, &quot;100&quot;, options); System.out.println(jsonObject.toString()); //转换为String，然后输出 } /** * 人脸检测 */ @Test public void testFaceCheck() throws IOException { //3.构造图片 String path =&quot;D:\\\\saas\\\\10-刷脸登录\\\\资源\\\\照片\\\\001.png&quot;; //上传图片有两种格式：一种是url另外一种是Beans64位的 byte[] bytes = Files.readAllBytes(Paths.get(path)); String encode = Base64Util.encode(bytes); //调用方法进行人脸检测 /** * 参数一：是图片的url或者图片的base64 * 参数二：图片形式 * 参数三：hashmap中的基本参数配置 * */ JSONObject jsonObject = client.detect(encode, &quot;BASE64&quot;, null); System.out.println(jsonObject.toString(2)); } /** * 人脸搜索,根据用户上传的图片和指定的人脸库中得所有人脸进行比较， * 获取相似度最高的一个或者某几个评分 * * 说明：返回值： * score:代表相似度评分(80分以上可以认为是同一个人) */ @Test public void testFaceSearch() throws IOException { //3.构造图片 String path =&quot;D:\\\\saas\\\\10-刷脸登录\\\\资源\\\\照片\\\\003.png&quot;; //上传图片有两种格式：一种是url另外一种是Beans64位的 byte[] bytes = Files.readAllBytes(Paths.get(path)); String encode = Base64Util.encode(bytes); //人脸搜索 /** * String image, * String imageType, * String groupIdList, * HashMap&lt;String, * String&gt; options */ JSONObject search = client.search(encode, &quot;BASE64&quot;, &quot;itcast&quot;, null); System.out.println(search.toString(2)); } /** * 人脸更新，根据的年龄增长，面部会发生一些变化 */ @Test public void testFaceUpdate() throws IOException { //2.参数设置 HashMap&lt;String,String &gt; options = new HashMap&lt;String, String&gt;(); options.put(&quot;quality_control&quot;,&quot;NORMAL&quot;); options.put(&quot;liveness_control&quot;,&quot;LOW&quot;); //3.构造图片 String path =&quot;D:\\\\saas\\\\10-刷脸登录\\\\资源\\\\照片\\\\002.png&quot;; //上传图片有两种格式：一种是url另外一种是Beans64位的 byte[] bytes = Files.readAllBytes(Paths.get(path)); String encode = Base64Util.encode(bytes); //4。调用API方法完成人脸注册 /** * 参数一：是图片的url或者图片的base64 * 参数二：代表的是图片的形式 一种叫做url另外一种叫做beans64 * 参数三：组ID（固定字符串） * 参数四：用户id * 参数五：hashmap中的基本参数配置 */ JSONObject jsonObject = client.updateUser(encode, &quot;BASE64&quot;, &quot;itcast&quot;, &quot;100&quot;, options); System.out.println(jsonObject.toString()); //转换为String，然后输出 }} 添加以上代码的时候可能还需要在xml文件里面添加一点内容: 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 刷脸登陆导入依赖： 1234567891011121314151617&lt;!-- 百度云AI API--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baidu.aip&lt;/groupId&gt; &lt;artifactId&gt;java-sdk&lt;/artifactId&gt; &lt;version&gt;4.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 二维码 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 二维码的生成：两种方式一种是生成一张图片保存到本地第二种是生成一张DataUrl的二维码 关于DataUrl的说明：https://segmentfault.com/a/1190000009692722， 就是一个其允许内容创建者向文档中嵌入小文件官网地址：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.itcast.test;import com.baidu.aip.util.Base64Util;import com.google.zxing.BarcodeFormat;import com.google.zxing.WriterException;import com.google.zxing.client.j2se.MatrixToImageConfig;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.QRCodeWriter;import javax.imageio.ImageIO;0import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.nio.file.Path;public class QrCodeTest {// public static void main(String[] args) throws WriterException, IOException {//// //1.填写二维码中的信息// String content =&quot; http://lyunqi.gitee.io/youreeverythingtome&quot;;// //2.通过zxing生成二维码//// //3.创建QrCodeWriter对象//// QRCodeWriter qrCodeWriter = new QRCodeWriter();//// BitMatrix bt = qrCodeWriter.encode(content, BarcodeFormat.QR_CODE, 200, 200);// //4.保存到本地//// Path path= new File( &quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\09章节\\\\test.png&quot;).toPath();////// MatrixToImageWriter.writeToPath(bt,&quot;png&quot;,path);//// } /** * 生成DataUrl的二维码 */ public static void main(String[] args) throws WriterException, IOException { //1.二维码中的信息 String content = &quot;http://www.itcast.cn&quot;; //2.通过zxing生成二维码(保存到本地图片，支持以data url的形式体现) //创建QRCodeWriter对象 QRCodeWriter writer = new QRCodeWriter(); //基本配置 BitMatrix bt = writer.encode(content, BarcodeFormat.QR_CODE, 200, 200); //创建ByteArrayOutputstream ByteArrayOutputStream os = new ByteArrayOutputStream(); //将二维码数据以byte数组的形式保存到ByteArrayOutputstream /** * 1：image对象 * 2：图片格式 * 3：Outputstream */ BufferedImage image = MatrixToImageWriter.toBufferedImage(bt); ImageIO.write(image,&quot;png&quot;,os); //对byte数组进行base64处理 String encode = Base64Util.encode(os.toByteArray()); System.out.println(new String(&quot;data:image/png;base64,&quot;+encode)); }}","link":"/2020/02/28/%E7%99%BE%E5%BA%A6%E4%BA%91%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"title":"秋天","text":"属于那个秋天 p{ font-family: FZSSJW; line-height: 1.9em; font-weight: 400; display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; } 也不知道从什么时候开始，时间过的越来越快，感觉自己的生活没有时间是属于自己的，就像上周，好不容易熬到了礼拜天，结果早上起来的时候腿酸痛的不行，你会想到一些奇怪的事情，其实是因为礼拜六团建那天跑的太用力，然后起床刷个牙洗个脸，看了看胡子，嗯~还可以接受明天刮把，然后把所有的衣服都给丢到洗衣机里面，然后转眼看到我很久没有洗的小白鞋，其实说起它还是有时间的一双鞋也是有故事的一双鞋，我把它用水泡了泡然后洗了之后我学会了用纸包着鞋因为这样可以干了之后脏东西就可以浮到纸上，不得不说，这是我妈都没教过我的。 干完这些事情，时间就到了11点半，我本想吃点东西，耳后是我哥；点外卖啦一会就到，我又回到了躺在床上躺了一会，嗯男生嘛一个月总会有那么几天.....这里忽略，吃完饭时间就来到了12点，穿好衣服就到了1点，你可能会问：你吃个饭这么久？穿个衣服这么久？，其实不是穿衣服时间久也不是吃饭时间久，只是我中间看了几集动漫，站在门口思考了一会，结果还是忘记了带口罩，我下午要出门去办个工资卡，嗯这公司还挺会玩。我进入银行的那一刻就觉得事情并不简单，因为评论这家银行不是很好，果不其然大堂经理仿佛觉得我是一个不可信的人，反复的确认我的信息，我说了我的工作证明，他还说我为什么不办一个暂住证，这让我很诧异，没有办法只有让他打公司人事电话确认，他这才给我填写单子。然后事情还没有交代完，人就不见了，我突然理解，那么多的差评是怎么来的，害，要不是岳麓区就你们家近点，我打死都不会再来了把 办完卡，太阳很大，那天阳光很好，出门的时候太阳照在脸上有点点温暖，所以骑车的时候也不是很冷，回去的路上经过一段柳树路，阳光刚好照在身上，身上飘过一阵小风，那一刻我很享受。生活也是如此把 回到家，得到两百块钱的伙食费，我拿着就跑去超市买了一百块钱的菜，由于没有估算好，自己还倒贴6块钱，买的菜不多，但是挺沉，说实话这只黑指鸡真的挺沉的，鸡：我可是43块钱呢能不沉吗？回到家我哥把菜煮好了大概也就1个多小时把，走过来对我说，再等等，饭还没熟，我....于是我们两个人坐在小板凳上等饭熟。 你说时间过的快吗? 确实挺快的，最大的感触就是忘不了团建那天拼命的赶时间，到最后头发没洗，脸没洗，一路上不敢说话，我就那个局外人把 其实秋天已经过去了，今天立冬了，因为超市里面喊着：立冬啦立冬啦，你吃饺子了嘛。当我看到路边的发黄的树叶都安静的呆在路边，我意识到秋天也悄无声息的走了我想他刚开始来的时候也是这样吧。今天是2020/11/9号 很有意思的事情-莫过于在陌生的城市到处走，反正没有人认识你，我想上帝也经常干这个事把 看了老胡的那一期关于30单身男人的生日，这让20岁的我，不得不思考，十年后我会是什么样呢？结婚了嘛？小孩多大了？或者还是单身呢？ 无论如何是值得期待，嗯，虽然现在迷茫，但是偶尔的打鸡血还是不错的。","link":"/2020/11/09/%E7%A7%8B%E5%A4%A9/"},{"title":"瞧瞧HikariCP和TkMyBatis以及MyBatis Generator","text":"先看看HiKariCPHikariCP官网: https://github.com/brettwooldridge/HikariCP 官网说明： 快速，简单，可靠。HikariCP是“零开销”生产就绪的JDBC连接池。库大约为130Kb，非常轻 是基于BoneCP做了不少的改进和优化，超快，快到SpringBoot2都宣布支持了 什么又是BoneCP呢？官网暂时没找到；据说是BoneCP在快速这个特点上做到了极致官方数据是C3P0等的25陪左右 为什么需要HikarICP呢？BoneCP作者已经放弃维护，并推荐使用HikariCPHi·ka·ri [hi·ka·’lē]（起源：日语）：轻；射线。 优化 自定义数组类型（FastStatementList）用来代替ArrayList：避免每次get（）调用都要进行range check，避免调用remove()时从头到尾的扫描；这也是我最佩服的地方 自定义集合类型（ConcurrentBag）：提高并发读写的效率 其他针对BoneCP缺陷的优化：比如对于耗时超过一个CPU时间片的方式调用研究（但不说具体优化） 等等其他优化 使用HikariCP1)，导入maven相关依赖 1234567891011121314151617181920212223&lt;!--整合HiKaiCP--&gt;&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt;&lt;!--排除tomcat-jdbc 已使用HikariCP--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt;&lt;/dependency&gt; 2），application.yml配置；测试使用的是本地连接数据库名为myshop 12345678910111213141516datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: root hikari: minimm-idle: 5 idle-timeout: 600000 maximm-pool-size: 10 auto-commit: true pool-name: MyHikariCP MAX-lifettime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1 SpringBoot整合TkMyBatis什么是TkMybatistkmybatis是在Mybatis框架的基础上提供了很多工具，开发更加高效 这里有一个官方说明： https://github.com/abel533/Mapper/wiki/6.example 使用1），导入maven依赖 123456&lt;!--引入tkmybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt;&lt;/dependency&gt; 2），application.yml配置 12345mybatis: //实体类存放路径 type-aliases-package: com.bjq.hello.springboot.domain //xml文件存放路径 mapper-locations: classpath:mapper/*.xml 创建通用父级接口主要作用是让DAO层的接口继承该接口，以达到使用tk.mybatis的目的 123456789101112131415package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** 自己的Mapper* 特别注意，该接口不能被扫描到，否则会出错* &lt;p&gt;Title:MyMapper&lt;/p&gt;* &lt;p&gt;Description:&lt;/p&gt;* @authorr Lusifer* @Version 1.0.0* @date 2019*/public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt; , MySqlMapper&lt;T&gt; {} 引入分页插件PageHelperPageHelper是mybatis的分页插件，支持多数据库，多数据源。可以简化数据库的分页插件操作，整合过程也极其简单，只需引入依赖即可； 1），导入maven引入pagehelper-spring-boot-starter依赖 123456 &lt;!--引入PageHelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; MyBatis Generator概述 可以无需手动创建编写实体类，DAO，XML配置文件，只需要使用MyBatis提供的一个Maven插件就可以自动生成所需的各种文件便能够满足基本的业务需求，如果业务比较复制只需要修改相关文件即可。 配置 1），在pom.xml文件中增加mybatis-generator-maven-plugin插件 12345678910111213141516171819202122&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 注意：configurationFile 自动生成所需的配置文件路径 自动生成的generatorConfig.xml文件配置 在src/main/resources/generator目录下创建generatorConfig.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;&quot;/&gt; &lt;!--配置tk.mybatis插件--&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;property name=&quot;mappers&quot; value=&quot;tk.mybatis.mapper.MyMapper&quot;/&gt; &lt;/plugin&gt; &lt;!--配置数据库连接--&gt; &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.connectionURL}&quot; userId=&quot;${jdbc.username}&quot; password=&quot;${jdbc.password}&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--配置实体类存放路径--&gt; &lt;javaModelGenerator targetPackage=&quot;com.bjq.hello.springboot.domain&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--配置 xml 存放路径--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;/&gt; &lt;!--配置DAO 存放路径--&gt; &lt;javaClientGenerator targetPackage=&quot;com.bjq.hello.springboot.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot; &gt;&lt;/javaClientGenerator&gt; &lt;!--配置需要指定生成的数据库和表,%代表所有表--&gt; &lt;table catalog=&quot;myshop&quot; tableName=&quot;%&quot;&gt; &lt;!--默认为false ，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema--&gt; &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;true&quot;/&gt; &lt;!--mysql配置--&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注意 ：如果需要dao层继承我们写的MyMapper请检查MyMapper的路径对不对 在src/main/resources目录下创建jdbc.properties数据库连接配置 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://localhost:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT&amp;useSSL=falsejdbc.username=rootjdbc.password=root 其他的呢都有相关注释 然后点击右边框Maven按钮 打开Plugins可以看到mybatis-generator(如果没有的话先刷新一下)然后双击mybatis-generator:generate即可运行 运行成功控制台不报错生成实体类以及DAO层： 控制台： 查看实体类和DAO层： 注意：测试的SpringBoot版本是2.1.2； 测试链接Mysql数据库版本是5.7.12；使用其他版本过高还有其他错误 在spring-boot-dependencies目录下把数据库版本改成低版本的 后面测试了一下虚拟机环境下Docker上的Mysql需要注意的地方：根据你docker上面的Mysql版本需要在spring-boot-dependencies里面改为对应的版本 测试CRUD功能检查HiKariCP连接池是否生效在控制台下编写Test方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RunWith(SpringRunner.class)@SpringBootTest@Transactional //加上注解@Rollback //回滚防止脏数据public class HelloSpringBootApplicationTests { @Autowired private UserMapper userMapper; @Test public void contextLoads() { }// 查询 @Test public void selectAll() { List&lt;User&gt; users = userMapper.selectAll(); users.forEach(System.out::println); }// 插入 @Test public void insert(){ User user = new User(); user.setAccountId(&quot;2&quot;); user.setName(&quot;小红&quot;); user.setToken(&quot;12456sdfsad_dfs&quot;); user.setGmtCreate(0L); user.setGmtModified(0L); int insert = userMapper.insert(user); if(insert &gt; 0){ System.out.println(&quot;成功&quot;); } }// 更新 @Test public void updateUser(){ User user = userMapper.selectByPrimaryKey(3L); user.setName(&quot;小黄&quot;); int i = userMapper.updateByPrimaryKey(user); if(i&gt;0){ System.out.println(&quot;更新成功&quot;); } }// 删除 @Test public void deleteUser(){ int i = userMapper.deleteByPrimaryKey(3L); if(i&gt;0){ System.out.println(&quot;删除成功&quot;); } }// PageHelper分页查询 @Test public void pageHelper(){ PageHelper.startPage(1,5); PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(userMapper.selectAll()); System.out.println(userPageInfo.getTotal()); System.out.println(userPageInfo.getPages()); userPageInfo.getList().forEach(System.out::println); }} 是在linux环境下测试；如果没有任何报错说明HikariCP是没有问题的 报错记录报错信息: 1Failed to execute goal org.mybatis.generator:mybatis-generator-maven-plugin:1.3.7:generate (default-cli) on project hello-spring-boot: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决办法：连接url地址后面要加上参数:?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false 报错信息： 12Failed to execute goal org.mybatis.generator:mybatis-generator-maven-plugin:1.3.7:generate (default-cli) on project hello-spring-boot: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone 报错参考: https://blog.csdn.net/oppo5630/article/details/52162783 以及运行成功了但是还是有错误信息: 1Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 参考: https://www.cnblogs.com/baby123/p/10436710.html 参考资料： https://github.com/brettwooldridge/HikariCP https://github.com/abel533/Mapper/wiki/6.example http://mybatis.org/generator/ 以及百度和谷老师 小例子源码： https://gitee.com/vilboys/hello-spring-boot 结束~~~","link":"/2019/11/26/%E7%9E%A7%E7%9E%A7HikariCP%E5%92%8CMyBatis-Generator/"},{"title":"阿里云服务器(Ubuntu)部署Docker","text":"前言在阿里云官网上购买一年或者一个月的服务器，这里的服务器是2G的 阿里云学生优惠链接：https://promotion.aliyun.com/ntms/act/campus2018.html?spm=5176.2020520101.0.0.5d674df5t2D6V7 这里还有一个可以白嫖6个月的服务器不过需要学生证明，可以试一下网址：https://developer.aliyun.com/adc/student/ （这个是真的不要钱，只要你通过考试即可获得） 购买过程就不多说了，只要跟着官网的步骤来就可以了，我这里服务器类型为（Ubuntu） 购买之后，通过SSH远程连接服务器进行操作，这里具体就是重置你的实例密码，如果不想进行SSH连接，也可以使用阿里云提供的Workbench远程连接，直接在网页进行操作即可，较为方便； 一，部署Docker1，准备工作：查看Linux 的内核； Docker 要求Linux内核版本为3.1以上 12root@iZwz9h6jmbefizt1vuhoa6Z:~# uname -r4.15.0-101-generic 2，安装必要的一些系统工具 12root@iZwz9h6jmbefizt1vuhoa6Z:~# apt-get updateroot@iZwz9h6jmbefizt1vuhoa6Z:~# sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 3，安装GPG证书： 123root@iZwz9h6jmbefizt1vuhoa6Z:~# curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -OK 4，写入软件源信息 1root@iZwz9h6jmbefizt1vuhoa6Z:~# sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 5，更新并且安装Docker-CE 12root@iZwz9h6jmbefizt1vuhoa6Z:~# apt-get -y updateroot@iZwz9h6jmbefizt1vuhoa6Z:~# apt-get -y install docker-ce 在上面这一条命令执行之前，你可以选择安装指定版本的Docker-CE 使用下面的命令可以安装指定的Docker-CE版本：(docker-ce = 你想要安装的指定版本) 1root@iZwz9h6jmbefizt1vuhoa6Z:~# sudo apt-get install docker-ce=5:19.03.5~3-0~ubuntu-bionic 这里没有安装指定的版本，选择的是默认安装； 6，查看 docker 版本 12root@iZwz9h6jmbefizt1vuhoa6Z:~# docker -vDocker version 19.03.12, build 48a66213fe 到此 docker 安装完成； 参考详细文章：https://juejin.im/post/5e8d3957e51d45471a1cc319 二，Docker 部署 Mysql1，我们去DockerHub上找到MYsql 的镜像，网址地址：https://www.docker.com/products/docker-hub 2，使用 docke- pull 命令拉取镜像 1root@iZwz9h6jmbefizt1vuhoa6Z:~# docker pull mysql 3，然后我们运行这个容器 1root@iZwz9h6jmbefizt1vuhoa6Z:~# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql -p：代表MySQL运行端口 --name 给这个容器取个名字 -e MYSQL_ROOT_PASSWORD 初始化MySQL 的默认密码 -d 运行容器的名字 4，本地测试连接： 到此结束~","link":"/2020/07/22/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-Ubuntu-%E9%83%A8%E7%BD%B2Docker/"},{"title":"成人日记","text":"这糟糕的一天 今天本该是一个开开心的日子，但是倒霉的人还是该倒霉，说好的停电早下班呢？结果不停电了。然后说好今天发工资呢？延迟两天这是什么意思？没看明白，发不出工资还他么使劲的找人？是不是有点说不过去了吧。 看到一个好的技术想学一下，结果第一步就进行不了，东西下载不下来。等待进一步的优化吧，今天的V2ex也上不去，害，就到这里吧，玩会休闲游戏。 这几天的心情其实都不是很好，作为一个成年人确实情绪管理不到位，不知道是自己太敏感了还是所谓外界原因，尽可能的去理解，但是不可能说完全的理解吧，这也是一个人的正常心理。 作为一个新青年，每天渴望学习一点新的知识，白天还能学点，但是到了晚上就不行了，晚上因为工作就已经懒得动了，有时候朋友叫上一起玩会游戏，完了就已经是十点左右了，对了，这几天睡得还算比较早吧，每次看B站呢都能刷到一些关于破防的东西，前天刷到一个生日的视频，昨天刷到一个，可能B站知道我要生日了，这算是故意的吧，但是每次都能让我破防好久，害，特别是五月天的转眼啊。一时间尽然不知道应该心疼自己还是谁。 作为一个成年人呢，生日其实对于大多数人来说不是太重要了，可以说长大之后真的就没有太多人能够陪你过生日了吧，生日。就是一个单体的孤单活动。除此之外真没有什么特别的意义。 你能想到吗，以后那群好友们，要不就是带孩子的要不就是开公司的要不就是忙着找对象呢，害，其实挺想回到 15 16 岁那时候那时候，虽然没有大手大脚的花钱，但是身边有一群陪着你的人，这应该是最好不过的了吧。 今天就写到这些吧，那天心情好点时候再发出去吧。 2020-12-18 今天的心情可以说是周转了一波又一波，其实明天不是很愿意去上班，其实没有太多的情绪，也就是该吃吃该喝喝的，今天也是学到了一句话，我其实是一个非常犹豫不决的人，特别小孩子，一直到今天我才知道我为什么会这样子，一个人在人生的关键时刻做出的选择是人的性格还有出生所决定的，年轻的时候谁都想自己可以飞黄腾达，但是再遇到了所谓的机遇的时候，人的价值还有出身都有会不同的结果。 思考了几秒，确实是这样，终于明白了很多很多时候呢，自己在很多时候会那么犹豫的时刻了，其实脑子里面并不是在思考很多事情，但是就是从骨子里透露出一股犹豫的劲。 明天呢是我的19岁生日，没有太多的情绪，觉得一定要去干嘛干嘛的，去旅游还是干啥的，不是不想，一个人呢去不到那么多的地方罢了。自己也过的不是很顺心，或者是因为这一年真的不好过吧，每一年的生日都在年末的时候，很难有人记得，很难有人记起来，也没有那么矫情要如何如何的，我想让自己过的舒服一点，至少在生日的这一天里面是这样的。 这个年纪了有人已经生小孩了，虽然自己没有，总是感觉，仿佛呢，昨天才从学校里面走出来，今天过来告诉我，准备结婚，买房子了，可能是一下子缓不过来，或者是自己还没准备好，其实挺难的说实话。 嗯…一直很感谢我的朋友们，其实没有那么多联系，这些天一直在思考，当初自己呢，为什么要那么早离开学校呢，终于在一个下午想通了，如果不是因为自己的幼稚行为，不会那么快从学校脱离出来吧，不是因为自己的傻行为，导致自己脸不好了，这一切都来自于我心里的自卑，很傻B的过于成熟了。但是在前几天收到了来自朋友的礼物，说实话心里还是挺高兴的，因为说起礼物，这还是第二次。 今天是这篇成人日记的第二部分，明天写完最后一个部分吧，2020-12-26 今天是2020年12月27号，我想了很久很久….生日快乐吧","link":"/2020/12/27/%E6%88%90%E4%BA%BA%E6%97%A5%E8%AE%B0/"},{"title":"Vue2.9.6版本升级暴走！","text":"前言： 因为一个springboot的项目需要用到我们的一个vue-ui的功能，但是在命令行中，运行命令是没有任何的反应，这就很奇怪了，在网上查找了一些个教程，都尝试过了，但是还是没有用，最后也是捣鼓了几天才解决了这个问题，在此稍微的记录一下 捣鼓过程1，网上大部分的教程都是： 12345npm uninstall vue-cli -g //意思是卸载旧的vue版本npm install -g @vue/cli //这一句话的命令是说安装vue的最新版本vue -V // 这句话的意思就是查看当前vue的版本 在这里反反复复的试了这几个命令，结果版本一直是我们的2.9.6。给我气的。 解决办法： 这里需要说明一下，因为我的电脑系统变量在这之前都是没有配过关于nodejs的路径，所以在这里特意调整了变量，这里我们需要调整两个位置的变量，一个是我们的PATH，另外需要我们新建一个NODE_PATH，这两个都需要设置一下 1，PATH的地方需要添加我们的nodejs安装的地方的node_global这个文件夹，比如说安装在D盘：”D:\\Program Files\\nodejs\\node_global” 注意这里我们的PATH环境变量是系统的环境变量，而用户的环境变量，应该是不用配也可以（我就不试了，我两个都配了） 2，NODE_PATH这个需要我们新建，有就不用新建，这里的环境变量，需要填写我们的nodejs下面的node_global的这个node_modules，比如说我的变量值就是这样的：” D:\\Program Files\\nodejs\\node_global\\node_modules\\ “ 3，到这里我们再回去捣鼓我们的那三个步骤就可以卸载旧版本了，以及升级我们的新的版本了，安装新版本vue的时候是可以指定版本的，具体自己查就知道了。 参考资料： https://www.jianshu.com/p/ba7c078837f3 https://blog.csdn.net/yang____yang/article/details/106302948 http://www.imooc.com/wenda/detail/495457 https://goobe.io/","link":"/2021/03/17/Vue2-9-6%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%9A%B4%E8%B5%B0%EF%BC%81/"},{"title":"Docker-compose的使用","text":"什么是Docker Compose： Docker Compose是Docker官网编排（Orchestration）项目之一，负责快速的部署分布式应用 镜像加速(使用阿里云的加速)： 登录注册一个阿里云，然后在控制台里面搜索一个镜像加速，然后点击打开这个页面最下面有一个镜像加速器里面有一个网址，复制下来 进入/etc/docker目录下通过配置daemon.json来使用加速器然后使用命令： 123456789root@ubuntu:/etc/docker# tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;:[&quot;https://zyw2lmzb.mirror.aliyuncs.com&quot;]}EOF#重启Dockersystemctl daemon-reloadsystemctl restart docker 重启完成后使用docker info即可查看你的仓库地址 概述：Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务 其官网文档说明地址：https://docs.docker.com/compose/ 其官网开源代码地址：https://github.com/docker/compose/releases 其官网下载地址：https://github.com/docker/compose/releases 简单来说就是简化我们docker的操作 安装Docker-composecompose支持Linux，macOS，Windows10，三大平台。这里在linux(Ubuntu18.04)环境下安装，使用下面的命令安装即可 第一句命令表示下载，第二句的作用是让你的root用户拥有这个文件的执行操作权限 12sudo curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 然后检查一下是否安装成功： 1docker-compose version 出现如下信息表示安装成功了 使用docker-compose我们在usr/local目录下新建一个文件夹取名为docker然后进去再创建一个tomcat的文件夹，然后进入tomcat在这个文件夹下面编写一个docker-compose的配置文件 1vi docker-compose.yml 里面的内容： 12345678version: '3.1' services: #服务 tomcat: #tomcat restart: always #开机自启动 image: tomcat #镜像名字 container_name: tomcat #容器名字 ports: - 8080:8080 #暴露的端口 运行这个文件的命令： 1docker-compse up 前提条件是你安装了docker，如果启动后访问的tomcat是404，访问不到tomcat的主页面接着往下看。 我们可以多开一个标签然后使用命令： 可以先查看运行中的docker 容器ID docker ps 进入tomcat容器 1docker exec -it 运行的tomcat容器ID /bin/bash 进入webapps目录下你会发现里面是空的，没有文件（tomcat的默认欢迎页面应该放在webapps/ROOT/index.jsp或者index.html） 解决的办法 webapps.dist里文件复制到webapps webapps.dist重命名为webapps 复制文件到webapps: 1cp -r webapps.dist/* ./webapps webapps.dist重命名为webapps： 1234#删除webappsrm -f webapps#重命名mv webapps.dist webapps 测试：访问 IP地址加上端口号8080 如果想和删除这个容器： 1docker-compose down 一个复制粘贴小技巧: 如果在平时复制一段代码的时候，复制进去之后你会发现格式全乱了，这个时候我们可以 输入：set paste （表示原样粘贴）回车 再按 i 然后再复制进来的内容就是原样的 部署Tomcat让其持久化在之前创建的docker-compose.yml这个文件里面添加两句话 123456789101112version: '3.1'services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: #数据卷 - ./webapps:/usr/local/tomcat/webapps environment: TZ: Asia/Shanghai #时区 运行这个文件 1docker-compose up -d 查看有没有运行的容器 1docker ps 使用ll命令然后你会发现在tomcat文件里多了一个webapps的文件夹（这不是自己创建的） 使用命令： 1docker exec -it tomcat /bin/bash cd到webapps目录下你会发现是空白的，这时候的状态就是同步的 重新开一个标签然后进入到这个文件夹内创建一个test文件，你会发现里面也会有test，如果你删除了这个test，那外面的容器也没有了test 这个时候我们去浏览器访问IP:8080会发现是404的状态，因为啥东西都没有 我们在外部的容器mkdir一个文件夹叫做ROOT然后进入这个文件夹vi 一个index.jsp 内容为Hello Docker-compose 这个时候再去访问就是这个样子 即使你把这个容器给down掉但是数据卷依然保留了下来，这样就完成了持久化 部署Mysql还是在usr/local的docker目录下新建一个文件夹取名为mysql。 cd到这个文件夹里面， 创建一个docker-compose.yml的配置文件。 123456789101112131415161718192021222324version: '3.1'services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql# MySQL 的 Web 客户端 adminer: image: adminer restart: always ports: - 8081:8080 使用命令： 1docker-compose up -d 查看运行中的容器 1docker ps 你会看到有两个容器在运行着，一个是Mysql，还有一个是Web页面的客户端 本地测试连接： 浏览器访问：IP地址：8081 这个就是web管理页面填写用户名和密码 数据库可以不填写登陆可以看到主页 Docker compose部署GitLabGitLab官方网址：https://about.gitlab.com/ 概述： GitLab是利用Ruby on Rails一个版本管理系统，其功能和Github类似，可以浏览源代码，除了Github以外还有一个码云，他们都有着类似的功能。如果你想自己搭建一个代码的仓库这个时候就出现了GitLab。 GitLab本身也是一个代码的仓库，但是他有一个社区版，可以在本地搭建，公司内部使用。 使用Docker-compose部署GitLab：新开一台虚拟机：通过docker来安装GitLab中文版，cd到usr/local目录下创建一个docker文件夹，进入docker文件夹，创建一个gitlab文件夹，然后进入gitlab文件夹下编写docker-compose配置文件 前提是安装了docker 以及docker-compose 12345678910111213141516171819202122version: '3'services: web: image: 'twang2218/gitlab-ce-zh' restart: always# 可以是域名 hostname: '192.168.199.148' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.199.148:8080' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 8080 ports: - '8080:8080' - '443:443' - '2222:22' volumes: - ./config:/etc/gitlab - ./data:/var/opt/gitlab - ./logs:/var/log/gitlab 使用命令运行这个文件 1docker-compose up -d 注意：第一次运行时间可能会比较久，请耐心等待有可能会访问到502的页面错误信息，这是正常的。最多十多分钟左右 我们可以观察日志信息： 1docker logs -f 运行容器的id 最后可以访问地址：http://ip:8080 端口8080是因为配置中设置的外部访问的地址是8080，默认为80 初始化完成后的页面效果如下： 刚初始化完成后是没有红色框内的东西，只有一个修改密码和确认密码，然后点击修改密码即可进入首页 (我这里是已经登录过得了，所以页面不太一样)，登录后可以点击一个带图标管理区域，创建一个新的用户(平时操作的时候最好是用一个普通的管理员，而不是超级管理员) 到此，GitLab的部署完成 把代码部署到GitLab可以先使用HTTPS模式的方式来克隆代码到本地，但是显然这样子是不安全的，那这个时候我们需要：免密登陆，实现的方式也很简单，如果用过GitHub基本都会，前提是：你必须安装了GIT到你的电脑上面；然后找到你的Git安装的目录找到\\usr\\bin这个目录下面打开命令行使用命令： 1ssh-keygen -t rsa -C &quot;这里填写你的GitLab的那个邮件就行&quot; 会输出以下信息：在你user目录下.ssh目录下生成了一个密钥 找到这个目录我们可以看到有两个文件。我们把id_rsa.pub里面的内容复制，然后在GitLab中点击头像–&gt;设置–&gt;找到SSH密匙–&gt;把复制过来的内容放到这里，然后起一个标题，最后点击Add Key 这个时候我们在本地就可以使用SSH的模式来克隆项目代码了，如果你使用的是TortoiseGit工具克隆代码。出现问题请参考：https://blog.csdn.net/u011511086/article/details/80606859 GitHub和Gitee的免密方式和上面的方式类似区别在于ssh的位置。 Docker commpose 部署Nexus一，编辑docker-compose 切换为root用户在 /usr/local/docker这个目录下面创建一个nexus的文件夹，然后进入这个文件夹，我们创建下面的内容： 前提是你已经下载了好nexus3.16.2的这个镜像版本 123456789101112version: '3.1'services: nexus3: restart: always image: sonatype/nexus3:3.16.2 container_name: nexus3 ports: - 8083:8081 volumes: - nexus-data:/nexus-datavolumes: nexus-data: 然后使用命令： 1docker-compose up -d 使用命令查看日志： 1docker-compose logs -f 二，访问页面 访问地址： ip + 8083 点击Signt in第一次登陆的时候，的登陆账户：admin，默认的密码：admin123，这是nexus3.3.16.2的默认密码；新版本可能有所不同，你可以根据它的提示找到，默认的密码，然后登陆进去之后，会要求你设置新的密码，下一步就行了。 里面有很多个仓库，平常我们使用最多的是中央仓库 三，在项目中使用Maven私服 以单体应用多模块的项目为例，项目中有一个专门做依赖管理的项目里面依赖了各种的版本依赖，都是去Maven的中央仓库下载的，还有一个commons，作为通用工具模块，web项目依赖了这个模块，连接搭建的nexus私服 配置代理仓库1234567891011121314151617181920212223242526&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://(这里是你得ip地址):8083/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://(这里是你得ip地址):8083/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 去到本地的Maven仓库，把spring的依赖全部都删除掉。 在IDEA命令中使用命令 1mvn clean package 会看到是在你的nexus私服中下载这些依赖 去到nexus的中央仓库就可以看到这些spring的依赖，因为本地没有这些依赖所以私服会去中央仓库下载这些依赖 三.1 解决模块之间的引用 像spring，以及junit等等 这些都是第三方的，我们自己有模块之间的引用，这些不是第三方的，所以如果你试着去打包会报错提示你找不到这些jar包 我们需要上传到nexus，要上传的话我们需要认证授权，找到我们本地Maven的conf下面的settings.xml文件在servers标签下面添加一段话：这里的admin 是nexus的默认的账户和密码 配置认证信息1234567891011 &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 在项目中的pom.xml文件添加： 配置自动化部署123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://(这里是你得ip地址):8083/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://(这里是你得ip地址):8083/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; cd到commons模块下使用命令： 1mvn deploy 上传全部命令： 1mvn deploy -Dmaven.test.skip 三.2 手动下载第三方的依赖 很多时候有些jar依赖是下载不下来的,用pom的方式是下载不下来的 在nexus上传jar包点击Upload，点击发行版仓库：maven-releases 预览maven-releases发行版仓库中即可查看添加的第三方依赖 遇到下载不了的时候可以通过这种方式解决下载依赖问题。 Docker-compose 部署Harbor什么是Harbor docker是一个用于存储和分发Docker镜像的企业级 Registry 服务器，可以用于管理和储存 Docker 镜像。Harbor 支持在多个仓库直接进行复制镜像，提供用户管理和访问控制和活动审计。 官网地址： https://github.com/goharbor/harbor Harbor由 以下服务组成（每一个服务都由一个容器运行） harbor-log registry redis harbor-db registryctl harbor-core harbor-jobservice harbor-portal nginx 部署Harbor官网下载1.8.0 offline的版本，然后上传到linux，到usr/local/docker目录下 1.上传完成后解压命令：完成后会生成一个harbor的文件夹。 1tar -zxvf harbor-offline-installer-v1.8.0.tgz 2.进入这个harbor的文件夹，然后我们修改一下 harbor.yml的主机，找到hostname 后面修改你的ip地址，这个文件中还包含了你的Harbor登录的密码， 可以往下翻一翻 123# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname: 192.168.199.xxx 3.执行安装脚本 使用命令： 注意：前提是你得注意的是你的80端口没有被占用，如果被占用的话，会报错修改一下端口即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071root@ubuntu:/usr/local/docker/harbor# ./install.sh // 输出如下[Step 0]: checking installation environment ...Note: docker version: 19.03.7Note: docker-compose version: 1.24.0[Step 1]: loading Harbor images ...Loaded image: goharbor/harbor-log:v1.8.0Loaded image: goharbor/harbor-db:v1.8.0Loaded image: goharbor/chartmuseum-photon:v0.8.1-v1.8.0Loaded image: goharbor/prepare:v1.8.0Loaded image: goharbor/harbor-jobservice:v1.8.0Loaded image: goharbor/nginx-photon:v1.8.0Loaded image: goharbor/notary-server-photon:v0.6.1-v1.8.0Loaded image: goharbor/clair-photon:v2.0.8-v1.8.0Loaded image: goharbor/harbor-migrator:v1.8.0Loaded image: goharbor/harbor-core:v1.8.0Loaded image: goharbor/redis-photon:v1.8.0Loaded image: goharbor/registry-photon:v2.7.1-patch-2819-v1.8.0Loaded image: goharbor/harbor-portal:v1.8.0Loaded image: goharbor/harbor-registryctl:v1.8.0Loaded image: goharbor/notary-signer-photon:v0.6.1-v1.8.0[Step 2]: preparing environment ...prepare base dir is set to /usr/local/docker/harborClearing the configuration file: /config/core/envClearing the configuration file: /config/core/app.confClearing the configuration file: /config/registry/root.crtClearing the configuration file: /config/registry/config.ymlClearing the configuration file: /config/registryctl/envClearing the configuration file: /config/registryctl/config.ymlClearing the configuration file: /config/log/logrotate.confClearing the configuration file: /config/nginx/nginx.confClearing the configuration file: /config/jobservice/envClearing the configuration file: /config/jobservice/config.ymlClearing the configuration file: /config/db/envGenerated configuration file: /config/log/logrotate.confGenerated configuration file: /config/nginx/nginx.confGenerated configuration file: /config/core/envGenerated configuration file: /config/core/app.confGenerated configuration file: /config/registry/config.ymlGenerated configuration file: /config/registryctl/envGenerated configuration file: /config/db/envGenerated configuration file: /config/jobservice/envGenerated configuration file: /config/jobservice/config.ymlloaded secret from file: /secret/keys/secretkeyGenerated configuration file: /compose_location/docker-compose.ymlClean up the input dir[Step 3]: starting Harbor ...Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... doneCreating registry ... doneCreating harbor-db ... doneCreating registryctl ... doneCreating redis ... doneCreating harbor-core ... doneCreating harbor-jobservice ... doneCreating harbor-portal ... doneCreating nginx ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://192.168.199.148. For more details, please visit https://github.com/goharbor/harbor 使用docker ps 可以看到很多运行的容器 访问Harbor 默认的用户名：admin ，密码：Harbor12345 配置客户端修改/etc/docker/daemon.json中添加一段话，（这个文件不存在，就新建这个文件） 后面填写你的仓库地址 123456{ &quot;registry-mirrors&quot;:[&quot;https://zyw2lmzb.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;:[ &quot;192.168.199.xxx&quot; ]} 修改完重启以下docker: 1systemctl restart docker 然后回到Harbor目录再： 1docker-compose start 然后新建一个项目： 给项目起一个名字 你也新建多个项目，也就是组件 1，添加我们自己镜像到myshop： 2，执行这句命令之前，你也得先有nginx这个镜像，也就是说你要先把这个镜像下载好 1234docker tag 镜像的名字:版本 ip地址/myshop/镜像的名字:版本//实列 docker tag nginx:latest 192.168.199.xxx/myshop/nginx:latest 1，执行完成后，docker images 你会看到有两个id 一样的nginx 只是他们的名字不一样 推送镜像：1，直接推送是推送不了的，我们先要登陆认证： 1docker login 192.168.199.xxx -u admin -p Harbor1234 2，推送命令： 1docker push 192.168.199.xxx/myshop/nginx:latest 查看myshop的项目下就会有一个nginx的最新版本的镜像 拉取这个镜像：1，先删除掉： 1docker rmi 镜像名字 2，复制PUll命令：在内网/会很快 123456docker pull 192.168.199.xxx/myshop/nginx:latest//输出信息:Digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266Status: Image is up to date for 192.168.199.148/myshop/nginx:latest192.168.199.148/myshop/nginx:latest 在网络设置的第一节：报错：Cannot mkdir: /usr/local/tomcat/webapps/ROOT is not a directory 解决方式：更换tomcat版本，不要用最新版的tomcat","link":"/2020/03/03/Docker-compose%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"No identifier specified for entity","text":"SpringBoot整合JPA的时候报错信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2019-12-20 17:35:51.802 ERROR 3156 --- [ main] o.s.boot.SpringApplication : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.AnnotationException: No identifier specified for entity: com.ihrm.domain.company.Company at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1699) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:573) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:495) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1089) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:859) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:780) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:333) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:139) [spring-boot-test-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:117) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:108) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:246) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runners.ParentRunner.run(ParentRunner.java:363) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runner.JUnitCore.run(JUnitCore.java:137) [junit-4.12.jar:4.12] at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) [junit-rt.jar:na] at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) [junit-rt.jar:na] at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) [junit-rt.jar:na] at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) [junit-rt.jar:na]Caused by: org.hibernate.AnnotationException: No identifier specified for entity: com.ihrm.domain.company.Company at org.hibernate.cfg.InheritanceState.determineDefaultAccessType(InheritanceState.java:266) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.cfg.InheritanceState.getElementsToProcess(InheritanceState.java:211) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.cfg.AnnotationBinder.bindClass(AnnotationBinder.java:731) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.source.internal.annotations.AnnotationMetadataSourceProcessorImpl.processEntityHierarchies(AnnotationMetadataSourceProcessorImpl.java:249) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.process.spi.MetadataBuildingProcess$1.processEntityHierarchies(MetadataBuildingProcess.java:222) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:265) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:861) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:888) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:57) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:390) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:377) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1758) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1695) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] ... 39 common frames omitted2019-12-20 17:35:51.804 ERROR 3156 --- [ main] o.s.test.context.TestContextManager : Caught exception while allowing TestExecutionListener [org.springframework.test.context.web.ServletTestExecutionListener@5b8dfcc1] to prepare test instance [com.ihrm.company.CompanyDaoTest@67e13bd0]java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:125) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:108) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:246) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runners.ParentRunner.run(ParentRunner.java:363) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) [spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.junit.runner.JUnitCore.run(JUnitCore.java:137) [junit-4.12.jar:4.12] at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) [junit-rt.jar:na] at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) [junit-rt.jar:na] at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) [junit-rt.jar:na] at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) [junit-rt.jar:na]Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.AnnotationException: No identifier specified for entity: com.ihrm.domain.company.Company at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1699) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:573) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:495) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1089) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:859) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:780) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:333) ~[spring-boot-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:139) ~[spring-boot-test-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:117) ~[spring-test-5.0.9.RELEASE.jar:5.0.9.RELEASE] ... 24 common frames omittedCaused by: org.hibernate.AnnotationException: No identifier specified for entity: com.ihrm.domain.company.Company at org.hibernate.cfg.InheritanceState.determineDefaultAccessType(InheritanceState.java:266) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.cfg.InheritanceState.getElementsToProcess(InheritanceState.java:211) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.cfg.AnnotationBinder.bindClass(AnnotationBinder.java:731) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.source.internal.annotations.AnnotationMetadataSourceProcessorImpl.processEntityHierarchies(AnnotationMetadataSourceProcessorImpl.java:249) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.process.spi.MetadataBuildingProcess$1.processEntityHierarchies(MetadataBuildingProcess.java:222) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:265) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:861) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:888) ~[hibernate-core-5.2.17.Final.jar:5.2.17.Final] at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:57) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:390) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:377) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1758) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1695) ~[spring-beans-5.0.9.RELEASE.jar:5.0.9.RELEASE] ... 39 common frames omitted 解决方式： 将实体类org.springframework.data.annotation.Id换成javax.persistence.Id 然后重启项目即可； 结束~","link":"/2019/12/20/No-identifier-specified-for-entity/"},{"title":"JasperReport填充数据的方式","text":"前言： 上一篇介绍了JasperReport是什么，以及使用创建模板，下面来说一下JasperReport的数据填充; 我们可以通过以下源码看到，JasperReport对报表模板中的数据填充有很多中方式，最典型的有以下两种 Parameters （参数）填充 DataSource (数据源) 填充 12345678 /*** 填充数据构造JasperPrint* is: 文件输入流* parameters：参数* dataSource：数据源*/public static JasperPrint fillReport(InputStream is, Map&lt;String, Object&gt; parameters,JRDataSource dataSource) throws JRException { 1.使用Parameters（也就是参数为Map） 的方式填充数据1，创建一个新的Jasper Report模板，删除掉不需要的Band，只留下Title，和Detail 1， 我们需要四个参数username,moblie,company,dept，在Outline面板下面找到Parameters选项，右键创建一个username。 Parameters代表的就是java代码传递过来的参数,参数可以自己创建 2，在Properties面板下修改名字，类型选择String类型，其他参数也是同样方法创建 3，然后把创建好的这四个Properties托入到Detail1 Bean中，前面是静态的文字说明。 $P代表的是：要用到Properties里面的数据了，括号里面就是参数的名称 创建完成后最好是把字体的样式设置为华文宋体，以免的麻烦 也可以点击Perview进行一个预览： 会要求你输入四个参数模拟数据，根据名称输入就好了，然后点击Reset即可看到效果 4，找到compile Report编译成为.jasper文件，复制到resources–&gt;templates文件夹下 5，编写一个测试的Controller，这里application.yml文件配置和启动类可以参考上一篇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.itcast.controller;import net.sf.jasperreports.engine.*;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.util.HashMap;import java.util.Map;@RestControllerpublic class JasperController2 { //基于 paramters 以Map的形式填充数据 @GetMapping(&quot;/testJasper2&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testParameters.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap(); //注意 设置的参数的key必须使用parameters中的参数名称是一样的 parameters.put(&quot;username&quot;,&quot;张三&quot;); parameters.put(&quot;mobile&quot;,&quot;110&quot;); parameters.put(&quot;company&quot;,&quot;云哈&quot;); parameters.put(&quot;dept&quot;,&quot;开发部&quot;); JasperPrint print = JasperFillManager.fillReport(fis,parameters,new JREmptyDataSource()); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } }} 浏览器访问：http://localhost:8082/testJasper2，如果报错提示：找不到文件路劲的话请重启`IDE`即可 1.2 数据源填充数据1，创建一个模板然后只留下Title以及Detail1 2，我们可以在Jaspersoft Studio先配置一个数据库连接，选择Repository Explorer 右键创建一个数据库连接，选择JDBC Connection 然后点击Next，这里配置基本的信息 最后点击Driver Classpath配置Mysql的驱动包，然后点击Test连接测试，如果弹出Successful就说明连接成功了 3，查询数据库，帮我们自动生成Fields Fields 就是数据库中的一个字段，也就是每一个对象的属性 在Outline面板里面右键模板的名称点击Dataset and Query Dialog点击打开，记得点击Read Fields执行查询 点击OK之后在Outline面板找到Fields下拉就可以看到刚查询出来的字段 然后把这些属性全部托入模板中：托入模板中之后会有两个框框，我们留下带$符号的，把前面的Static Text删除掉即可 然后字体样式选择华文宋体避免中文出现不了问题 然后点击Preview预览效果就可以看到你数据库中的数据了，如果数据之间显示相隔的太多，我们可以修改Detail1的高度改成矮一点的 A，同样的找到源文件，然后找到compile Report编译成为.jasper文件，复制到resources–&gt;templates文件夹下 B，编写一个测试的Controller： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.itcast.controller;import net.sf.jasperreports.engine.*;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.DriverAction;import java.sql.DriverManager;import java.sql.SQLException;import java.util.HashMap;import java.util.Map;@RestControllerpublic class JasperController3 { //基于 JDBC数据源的形式填充数据 @GetMapping(&quot;/testJasper3&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testComm.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap(); //parameters.put(&quot;cid&quot;,&quot;1&quot;); Connection conn = getConnection();// JasperController3 controller3 = new JasperController3();// Connection conn = controller3.getConnection(); JasperPrint print = JasperFillManager.fillReport(fis,parameters,conn); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } //编写一个连接jdbc方法 public Connection getConnection(){ Connection conn = null; try { //获取驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取连接url conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/ihrm&quot;,&quot;root&quot;,&quot;root&quot;); }catch (SQLException e){ e.printStackTrace(); }catch (ClassNotFoundException e){ e.printStackTrace(); } return conn; }} C，浏览器访问：http://localhost:8082/testJasper2 ，如果报错文件找不到可以重启IDE 上面是查询全部的信息，如果想要查询某一个企业或者某一个部门，我们可以传递一个参数。 首先我们在JasperSoft Studio里面创建一个Parameters，取名可以叫做Cid的参数，或者其他。 然后找到之间编写的sql查询语句去构造查询条件，在Outline面板里面右键模板的名称点击Dataset and Query 点击OK之后再去预览就会要你输入一个Cid，输入即可看到效果，最上方运行方式一定要选择在你的数据库中运行，不然没有效果 A，编写一个测试Controller，也就是在Map中传递一个参数，去查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.itcast.controller;import net.sf.jasperreports.engine.*;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.DriverAction;import java.sql.DriverManager;import java.sql.SQLException;import java.util.HashMap;import java.util.Map;@RestControllerpublic class JasperController3 { //基于 JDBC数据源的形式填充数据 @GetMapping(&quot;/testJasper3&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testComm.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap(); parameters.put(&quot;cid&quot;,&quot;1&quot;); Connection conn = getConnection();// JasperController3 controller3 = new JasperController3();// Connection conn = controller3.getConnection(); JasperPrint print = JasperFillManager.fillReport(fis,parameters,conn); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } //编写一个连接jdbc方法 public Connection getConnection(){ Connection conn = null; try { //获取驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取连接url conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/ihrm&quot;,&quot;root&quot;,&quot;root&quot;); }catch (SQLException e){ e.printStackTrace(); }catch (ClassNotFoundException e){ e.printStackTrace(); } return conn; }} B，浏览器访问：http://localhost:8082/testJasper3 ，如果报错文件找不到可以重启IDE 1.2.2 JAVABean数据源如果在连接的时候担心内存泄漏的问题，我们可以使用JavaBean的方式，来填充数据。 1，同样也是创建一个新的Jasper Report模板，删除不需要的模板，留下Title以及Detail1 2，我们需要创建几个参数Fields，注意Fields的name和你的实体类名称是一样的，然后托入Detail 1,字体样式选择华文宋体。 3，然后编译compile Report，复制.jasper文件到resources–&gt;templates文件夹下 4，编写一个测试Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.itcast.controller;import cn.itcast.domain.User;import net.sf.jasperreports.engine.JRException;import net.sf.jasperreports.engine.JasperExportManager;import net.sf.jasperreports.engine.JasperFillManager;import net.sf.jasperreports.engine.JasperPrint;import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class JasperController4 { //基于 javaBean数据源的形式填充数据 @GetMapping(&quot;/testJasper4&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testBean.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap&lt;&gt;(); //1.从对象中获取list集合 List&lt;User&gt; userList = getUserList(); //2.通过list集合创建javaBean的数据源对象 JRBeanCollectionDataSource ds = new JRBeanCollectionDataSource(userList); //构造javaBean数据源 JasperPrint print = JasperFillManager.fillReport(fis,parameters,ds); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } //模拟创建数据 public List&lt;User&gt; getUserList(){ List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i =0;i&lt;10;i++){ User user = new User(i+&quot;&quot;, &quot;用户&quot;+i, &quot;允浩科技&quot;,&quot;讲师&quot;, &quot;1380000000&quot;+i); list.add(user); } return list; }} 5，java实体类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.itcast.domain;public class User { private String id; private String username; private String mobile; private String company; private String dept; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getMobile() { return mobile; } public void setMobile(String mobile) { this.mobile = mobile; } public String getCompany() { return company; } public void setCompany(String company) { this.company = company; } public String getDept() { return dept; } public void setDept(String dept) { this.dept = dept; } public User(String id, String username, String mobile, String company, String dept) { this.id = id; this.username = username; this.mobile = mobile; this.company = company; this.dept = dept; }} 浏览器访问：http://localhost:8082/testJasper4，如果报错提示：找不到文件路劲的话请重启`IDE`即可 2，分组报表1，同样也是创建一个新的Jasper Report模板，删除不需要的模板，留下Title以及Detail1 2，再创建几个Fields，也可以从之前的模板中复制过来也可以，接着托入Deatail 1中 3，创建分组，在Outline面板中找到右键模板名称选择：Create Group，根据企业进行分组 然后点击Next 勾选上 Add the Group Header 和 Add the Group Footer 点击完成你会看到模板中多了两个Bead，可以在Header里面添加展示分组的名称，比如我以企业名称为分组，把companye托入到Header中，双击打开 然后选中选择字体样式为华文宋体，如果你要想统计多少条数目或者需要一个页码，在Outline面板中找到Variables下拉你会看到很多的内置方法，比如当前页码和总页数。 我们可以创建自己的参数：右键创建一个 Create Variables 右键创建一个 Create Variables然后这个totalNum拖入到Group Footer 1当中，如果想要当前的页码 找到PAGE_NUMBER拖入到Page Footer中 3，编写一个测试Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.itcast.controller;import cn.itcast.domain.User;import net.sf.jasperreports.engine.JRException;import net.sf.jasperreports.engine.JasperExportManager;import net.sf.jasperreports.engine.JasperFillManager;import net.sf.jasperreports.engine.JasperPrint;import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class JasperController5 { //分组报表 @GetMapping(&quot;/testJasper5&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testGroup.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap&lt;&gt;(); //1.从对象中获取list集合 List&lt;User&gt; userList = getUserList(); //2.通过list集合创建javaBean的数据源对象 JRBeanCollectionDataSource ds = new JRBeanCollectionDataSource(userList); //构造javaBean数据源 JasperPrint print = JasperFillManager.fillReport(fis,parameters,ds); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } public List&lt;User&gt; getUserList(){ List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i =0;i&lt;10;i++){ User user = new User(i+&quot;&quot;, &quot;itcast&quot;+i, &quot;1380000000&quot;,&quot;传智播客&quot;, &quot;讲师&quot;+i); list.add(user); } for (int i =0;i&lt;5;i++){ User user = new User(i+&quot;&quot;, &quot;itheima&quot;+i, &quot;1380000000&quot;,&quot;黑马&quot;, &quot;讲师&quot;+i); list.add(user); } return list; }} 浏览器访问：http://localhost:8082/testJasper5，如果报错提示：找不到文件路劲的话请重启`IDE`即可 3，父子报表1，同样也是创建一个新的Jasper Report模板，删除不需要的模板，留下Title以及Detail1 2，找到Sbreport托入Detail 1 3，选择本地模板,点击Browse查找 4，接下来选择你的模板： 然后点击ok 5，我们再创建两个个Parameters取名为subpath,sublist，点击模板中的Sbreport 编写子报表需要的数据： 1new net.sf.jasperreports.engine.data.JRBeanCollectionDataSource($P{sublist}) 6，然后编译你的父报表和你的子报表，把.jasper文件复制到resources–&gt;templates文件夹下 7，编写一个测试Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.itcast.controller;import cn.itcast.domain.UserCount;import net.sf.jasperreports.engine.*;import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class JasperController07 { /** * 父子报表 */ @GetMapping(&quot;/testJasper7&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws Exception { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/main01.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap&lt;&gt;(); //参数：子报表的路径 Resource subResout = new ClassPathResource(&quot;templates/testCharts.jasper&quot;); parameters.put(&quot;sublist&quot;,getUserCountList());//子报表需要的数据 parameters.put(&quot;subpath&quot;,subResout.getFile().getPath()); //子报表的路径 JasperPrint print = JasperFillManager.fillReport(fis,parameters,new JREmptyDataSource()); JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } public List&lt;UserCount&gt; getUserCountList() { List&lt;UserCount&gt; list = new ArrayList&lt;&gt;(); UserCount uc1 = new UserCount(&quot;doge&quot;,1000l); UserCount uc2 = new UserCount(&quot;google&quot;,1000l); UserCount uc3 = new UserCount(&quot;baidu&quot;,1000l); list.add(uc1); list.add(uc2); list.add(uc3); return list; }} 浏览器访问：http://localhost:8082/testJasper7，如果报错提示：找不到文件路劲的话请重启`IDE`即可 end","link":"/2020/02/09/JasperReport%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"SSM简单的整合学习","text":"最近花了一段时间去学习了Spring+SpringMVC+Mybatis这三个框架本篇博客主要记录整合学习过程,关于三个框架的理论知识,大家各有见解，这里就没有过多的概述了，推荐不错的一个java学习资料，覆盖大部分知识还包括面试技巧之类的 (网站链接)Java学习/面试指南整合软件环境：使用的IDE是: IDEA2019 使用测试服务器: Tomcat8.5 Spring+SpringMVC+Mybatis整合开发用到Maven项目管理工具 个人觉得好处是添加jar包统一jar包比较方便,不用像以前去文件夹里面找可以直接搜索复制过来就好了 引自：[how2j.cn-Maven教程] 第一步：创建Maven项目点击Maven勾选上Create from archetype选择 webapp： 点击Next； 写上你的GroupId类似main目录下java的目录结构(包) 写上你的ArtifactId就相当于你的项目名称项目唯一标识符 点击Next; 确认项目名称，这一步你可以看到Maven配置中的参数,我这里选择的是我本地中的Maven3.5.3仓库地址 (也可以不做改动) 确认你的项目后点击**[Finish]**即可 等待一会，控制台就会输出创建成功的提示信息,可以把**[Enable Auto-Import]**这个提示会在每次pom.xml有改动时出现,自动导入，可以省的一些事情 第二：搭建项目目录结构下面是创建的默认的目录结构 需要注意的是:webapp默认是没有java源文件也没有test目录的 遵循Maven的统一项目结构，下面是完整的目录结构 提示：我们可以在 IDEA 中右键目录然后选择【Make Directory as】，让 IDEA 识别不同的目录作用 这里的目录建好之后还需要设置一下，让 IDEA 识别目录作用，选择【File】&gt;【Project Structure】： 点击OK！完成 第三步：配置文件内容在**[pom.xml]**文件中声明依赖的jar包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM&lt;/name&gt; &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version} &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在**[web.xml]**声明过滤器和配置DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在**[spring-mybatis.xml]中完成 **spring 和 mybatis 的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;cn.bjq.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.bjq.entity&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.bjq.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 在**[spring-mvc.xml]中完成 **Spring MVC 的相关配置 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;cn.bjq.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 在**[jdbc.properties]**中配置 c3p0 数据库连接池 1234567891011121314151617jdbc.driver=com.mysql.jdbc.Driver#数据库地址jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8#用户名jdbc.username=root#密码jdbc.password=root#最大连接数c3p0.maxPoolSize=30#最小连接数c3p0.minPoolSize=10#关闭连接后不自动commitc3p0.autoCommitOnClose=false#获取连接超时时间c3p0.checkoutTimeout=10000#当获取连接失败重试次数c3p0.acquireRetryAttempts=2 在**[logback.xml]**中完成日志输出的相关配置 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt;&lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;&lt;/root&gt;&lt;/configuration&gt; 这样就算完成了基本配置 第四步：测试SSM框架测试用的数据库 12345678910111213141516171819DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `pwd` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (1, 'name', 23);INSERT INTO `user` VALUES (2, '我没有三颗心脏', 17);INSERT INTO `user` VALUES (3, '直播', 18);INSERT INTO `user` VALUES (4, '闪现', 20);INSERT INTO `user` VALUES (5, '学不会', 123);INSERT INTO `user` VALUES (6, 'name', 23);INSERT INTO `user` VALUES (7, '李清照', 22);INSERT INTO `user` VALUES (8, '李清照', 22); 在*[cn.bjq.entity]**包下面新建实体类User.java 123456789101112131415161718package cn.bjq.entity;/*** user实体类** */public class User { private int id; private String name; private int pwd; /*get和set方法*/} 在*[cn.bjq.dao]**下面新建dao接口:UserDao.java** 12345678910111213141516171819202122232425262728package cn.bjq.dao;import cn.bjq.entity.User;import java.util.List;public interface UserDao { /* * findUserById是查询信息的处理方法 * */ User findUserById(int id); /* * 处理登陆的方法 * login * */ public User login(User user); /* * 查询所有学生的信息 * */ public List&lt;User&gt; getUserList();} 在mapper文件夹下创建相关的mapper映射文件:UserDao.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 设置为IUserDao接口方法提供sql语句配置 --&gt;&lt;mapper namespace=&quot;cn.bjq.dao.UserDao&quot;&gt; &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;pwd&quot; column=&quot;pwd&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 查询一条数据 --&gt; &lt;select id=&quot;findUserById&quot; resultType=&quot;cn.bjq.entity.User&quot; parameterType=&quot;int&quot;&gt; SELECT * FROM user WHERE id = #{id} &lt;/select&gt; &lt;!--处理登陆 --&gt; &lt;select id=&quot;login&quot; parameterType=&quot;cn.bjq.entity.User&quot; resultMap=&quot;UserResult&quot;&gt; select * from user where name=#{name} and pwd=#{pwd} limit 1 &lt;/select&gt; &lt;!--查询所有信息--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;cn.bjq.entity.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 接着在**[cn.bjq.service]下创建UserService**接口 12345678910111213141516171819202122232425262728package cn.bjq.service;import cn.bjq.entity.User;import java.util.List;public interface UserService { /* * 查询单个人信息 * */ public User findUserById(int id); /* * 处理登陆的方法 * */ public User login(User user); /* * 查询所有学生信息 * */ public List&lt;User&gt; getUserList();} 接着在**[cn.bjq.service.impl]下创建实现类UserSserviceImpl** 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.bjq.service.impl;import cn.bjq.dao.UserDao;import cn.bjq.entity.User;import cn.bjq.service.UserService;import org.springframework.stereotype.Service;import java.util.List;import javax.annotation.Resource;@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService { @Resource private UserDao userDao; /* * 查询单个个人信息 * */ public User findUserById(int id) { return userDao.findUserById(id); } /* * 处理登陆可以忽略 * */ public User login(User user) { return userDao.login(user); } /* * 实现查询所有用户信息 * */ public List&lt;User&gt; getUserList() { return userDao.getUserList(); }} 在**[cn.bjq.controller]下创建控制器类UserController** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.bjq.controller;import cn.bjq.entity.User;import cn.bjq.service.UserService;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.util.List;@Controllerpublic class UserController { @Resource public UserService userService; @RequestMapping(&quot;/findUser&quot;) public String findUser(Model model) { int id =2; User user = userService.findUserById(id); model.addAttribute(&quot;user&quot;, user); return &quot;result&quot;; } /* * 处理Login的请求 * */ @RequestMapping(&quot;/login&quot;) public String login(User user, HttpServletRequest request) { User resultUser = userService.login(user); if (resultUser == null) { return &quot;redirect:/index.jsp&quot;; } else { return &quot;user&quot;; } } /* * 查询所有用户的信息 * */ @RequestMapping(&quot;/getUserList&quot;) public ModelAndView getUserList(User user,HttpServletRequest request) { List&lt;User&gt; userList = userService.getUserList(); User resultUser = userService.login(user); ModelAndView model = new ModelAndView(); if (resultUser == null) { request.setAttribute(&quot;user&quot;, user); request.setAttribute(&quot;errorMsg&quot;, &quot;请认真核对账号、密码！&quot;); model.setViewName(&quot;redirect:/index.jsp&quot;); return model; } else { model.addObject(&quot;userList&quot;, userList); model.setViewName(&quot;user&quot;); return model; } }} 注意:这里原本我是Login方法实现登陆的，后来转移到lgetUserList方法上面了 第五步：测试结果在**[WEB-INF/views]**下面新建一个login页面(我这里用的是index.jsp) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%-- Created by IntelliJ IDEA. User: jealous Date: 2019/8/16 Time: 13:22 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkIP(){//js表单验证方法 var name=document.getElementById(&quot;name&quot;).value;//通过id获取需要验证的表单元素的值 var pwd=document.getElementById(&quot;pwd&quot;).value;//通过id获取需要验证的表单元素的值 if(name==null || name==&quot;&quot;){//当上面获取的值为空时 alert(&quot;用户名不能为空！&quot;);//弹出提示 return false;//返回false（不提交表单） } if(pwd==null || pwd==&quot;&quot;) { alert(&quot;密码不能为空哟&quot;); return false; } return true;//提交表单 } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- &lt;a href=&quot;/findUser&quot;&gt;点击查询详细信息&lt;/a&gt;--%&gt; &lt;FORM method=&quot;post&quot; ACTION=&quot;${pageContext.request.contextPath}/getUserList&quot; name=&quot;ipform&quot; onsubmit=&quot;return checkIP();&quot;&gt; &lt;!--使用onsubmit方法进行表单验证--&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt; 密 码:&lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;查询&quot; /&gt; &lt;/FORM&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=text/javascript&gt; if ('${errorMsg}' == '') { alert('${errorMsg}'); }&lt;/script&gt; 在**[WEB-INF/views]**下面新建一个User.jsp页面用来放用户信息 1234567891011121314151617181920212223242526272829303132333435&lt;%-- Created by IntelliJ IDEA. User: jealous Date: 2019/8/17 Time: 20:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt; &lt;tr&gt; &lt;td&gt;id:${user.id}&lt;/td&gt; &lt;td&gt;name:${user.name}&lt;/td&gt; &lt;td&gt;pwd:${user.pwd}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 配置好tomcat服务器运行页面 index.jsp user.jsp 到这里就算基本OK了通常我们还会在 Controller 和 Service 层中引入工厂模式，这里仅仅是创建了一个简单的 SSM 项目，用以测试而已 参考资料 来自这篇博客的详细说明https://www.jianshu.com/p/3098050b0d14 来自万能的度娘和谷老师以及不太聪明的脑子","link":"/2021/01/17/SSM%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%AD%A6%E4%B9%A0/"},{"title":"Springboot2.x踩过的坑","text":"在连接本地数据库的时候，执行出了一个错误123spring.datasource.url=jdbc:mysql://localhost:3306/spring_cachespring.datasource.username=rootspring.datasource.password=root 错误代码 1234567891011121314151617java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:129) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:89) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:63) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:73) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:827) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:447) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:237) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:199) ~[mysql-connector-java-8.0.17.jar:8.0.17] at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:136) ~[HikariCP-3.2.0.jar:na] at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:369) ~[HikariCP-3.2.0.jar:na] at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:198) ~[HikariCP-3.2.0.jar:na] at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:467) [HikariCP-3.2.0.jar:na] at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:541) [HikariCP-3.2.0.jar:na] at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) [HikariCP-3.2.0.jar:na] 看了一下导入的mysql数据库版本 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 原因是高版本的原因; 所以在配置的时候应该是这样配 123spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root 重启即可; Springboot2.x整合redis 使用自定义CacheManager在springboot1.x版本是这样写的 1234567891011121314151617181920212223242526@Configurationpublic class MyRedisConfig { @Bean public RedisTemplate&lt;Object, Employee&gt; empRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; ser = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(ser); return template; } @Bean public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; empRedisTemplate){ RedisCacheManager cacheManager = new RedisCacheManager(empRedisTemplate); //key多了一个前缀 //使用前缀，默认会将CacheName作为key的前缀 cacheManager.setUsePrefix(true); return cacheManager; }} 然而在springboot2.x以后代码有了点区别构造器也有了点区别 RedisCacheConfiguration根据名字都能想到它是提供redis的配置。 123456789101112131415@Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { //初始化一个RedisCacheWriter RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory); //设置CacheManager的值序列化方式为json序列化 RedisSerializer&lt;Object&gt; jsonSerializer = new GenericJackson2JsonRedisSerializer(); RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair .fromSerializer(jsonSerializer); RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig() .serializeValuesWith(pair); //设置默认超过期时间是30秒 defaultCacheConfig.entryTtl(Duration.ofSeconds(30)); //初始化RedisCacheManager return new RedisCacheManager(redisCacheWriter, defaultCacheConfig); } 如果不设置CacheManager数据是这样子的 参考来自 参考来自 查询部门的时候使用redis缓存的错误问题错误信息: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.bjq.cache.bean.Department] at org.springframework.core.serializer.DefaultSerializer.serialize(DefaultSerializer.java:43) ~[spring-core-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:63) ~[spring-core-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:35) ~[spring-core-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.serialize(JdkSerializationRedisSerializer.java:94) ~[spring-data-redis-2.1.11.RELEASE.jar:2.1.11.RELEASE] at org.springframework.data.redis.serializer.DefaultRedisElementWriter.write(DefaultRedisElementWriter.java:43) ~[spring-data-redis-2.1.11.RELEASE.jar:2.1.11.RELEASE] at org.springframework.data.redis.serializer.RedisSerializationContext$SerializationPair.write(RedisSerializationContext.java:241) ~[spring-data-redis-2.1.11.RELEASE.jar:2.1.11.RELEASE] at org.springframework.data.redis.cache.RedisCache.serializeCacheValue(RedisCache.java:244) ~[spring-data-redis-2.1.11.RELEASE.jar:2.1.11.RELEASE] at org.springframework.data.redis.cache.RedisCache.put(RedisCache.java:150) ~[spring-data-redis-2.1.11.RELEASE.jar:2.1.11.RELEASE] at org.springframework.cache.interceptor.AbstractCacheInvoker.doPut(AbstractCacheInvoker.java:87) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.cache.interceptor.CacheAspectSupport$CachePutRequest.apply(CacheAspectSupport.java:820) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:429) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:345) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:61) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.1.10.RELEASE.jar:5.1.10.RELEASE] at com.bjq.cache.service.DeptService$$EnhancerBySpringCGLIB$$61580dc1.getDept(&lt;generated&gt;) ~[classes/:na] at com.bjq.cache.controller.DeptController.getDept(DeptController.java:19) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_211] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_211] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_211] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_211] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:893) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:798) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:94) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1589) [tomcat-embed-core-9.0.26.jar:9.0.26] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.26.jar:9.0.26] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_211] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_211] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.26.jar:9.0.26] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_211] 原因很简单，因为对要缓存的java对象必须实现 Serializable 接口，因为Spring会将对象先序列化再存入Redis，如果不实现Serializable就会出现这种错误 1java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.bjq.cache.bean.Department] 参考来自 Springboot整合elasticsearch时的一个大问题错误消息： 123456789101112131415161718192021222324252627io.searchbox.client.config.exception.CouldNotConnectException: Could not connect to http://localhost:9200 at io.searchbox.client.http.JestHttpClient.execute(JestHttpClient.java:70) at io.searchbox.client.http.JestHttpClient.execute(JestHttpClient.java:60) at com.bjq.elastic.Springboot03ElasticApplicationTests.contextLoads(Sprintboot03ElasticApplicationTests.java:38) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675) at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:125) at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:132) at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:124) at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:74) at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:104) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:62) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:43) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:35) at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:202) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:198) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) at 后面还有很多。。。。。 这个问题困扰了我好几个小时尤其是这句话 1javaio.searchbox.client.config.exception.CouldNotConnectException: Could not connect to http://localhost:9200 我始终不明白出错在哪，我在全局配置里面写的是服务器的ip地址是这样的 1spring.elasticsearch.rest.uris=http://192.168.xx.xx:9200 然后去网上找了半天的资料；没结果 然后我晚上又重新写了一个，总结了几个方面的问题 第一个我们需要在实体类的ID属性加上 @JestId注解 12@JestIdprivate Integer id; 第二个是版本的问题； 这个我使用的Jest的 5.3.4版本，重新测试的版本使用的是6.3.1再测试一下 最后一个是在全局配置文件中写错了这句话 错误写法: 1spring.elasticsearch.rest.uris=http://192.168.x.x:9200 正确写法: 1spring.elasticsearch.jest.uris=http://192.168.x.x:9200 修正这几个错误就可以再试着运行； 查看：","link":"/2019/10/17/Springboot%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"title":"elasticsearch安装和基本使用","text":"首先elasticsearch是什么?这里来自官方文档的一段说明: Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 elasticsearch也是基于 Lucene 来开发的只不过在这上面提供了更好的封装；通过 简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单 。 详细步骤:先决条件： 5.6.9版本的elasticsearch 一个可以使用的虚拟机 还有docker 这是示例版本是：5.6.9版本的elasticsearch 以docker的方式启动 1，安装:执行命令; 1docker pull elasticsearch 你可以这么写但是，可能会出错; 所以我是这么写的：执行命令 1docker pull elasticsearch:5.6.1 我参考了这篇博客 https://blog.csdn.net/Zarkjobs/article/details/100763040 安装完成后使用命令：检查是否下载好；如图1 1docker images 2，接着我们试着运行:执行命令; 1docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name ES01 5c1e1ecfe33a 因为docker.io/elasticsearch是用java写的，默认初始化会占用两个G的内存，为了节约我们可以改变一下这个大小; 使用命令：设置初始化的内存为256m，和一个最大使用的也是256m； 1-e ES_JAVA_OPTS=&quot;Xms256m -Xmx256m&quot; -d：后台运行 -p：暴露端口 9300：在分布式下各个节点通信的节点是9300 –name ：可以自己定义一个名字 查看:虚拟机地址:9200 如果出现了像json数据的画面就说明elasticsearch安装完成了 使用一下：elasticsearch用Postman软件代替测试 以下测试都参考来自：官网文档 我们可以发送一个 JSON 的数据来put一个对象； 每个文档代表一个员工。在Elasticsearch中存储数据的行为就叫做索引(indexing) 以 员工文档 的形式存储为例：一个文档代表一个员工数据。存储数据到 ElasticSearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。 一个 ElasticSearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 所以为了创建员工目录，我们将进行如下操作： 为每个员工的**文档(document)**建立索引，每个文档包含了相应员工的所有信息。 每个文档的类型为employee。 employee类型归属于索引megacorp。 megacorp索引存储在Elasticsearch集群中。 代码来自文档 12345678PUT /megacorp/employee/1{ &quot;first_name&quot; : &quot;John&quot;, &quot;last_name&quot; : &quot;Smith&quot;, &quot;age&quot; : 25, &quot;about&quot; : &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]} 例子中需要我们发一个PUT请求后面加上/megacorp/employee/1 我们可以这样写：http://192.168.43.78:9200/megacorp/employee/1 再选中PUT请求；点击Body选中raw按钮，文本类型选择JSON数据类型;最后点击Send发送 可以看到我这里的结果是update，因为已经提前put过几次了 其他的详细教程，可以参考：官网文档 Springboot整合jest有两种方式： ①： Jest（默认不生效） 需要导入jest的工具包（io.searchbox.client.JestClient）步骤：1），导入jar包:版本是6.3.1 12345 &lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt;&lt;/dependency&gt; 2），在全局配置文件中添加相关配置（千万不要写错了这一步） 12#使用jest客户端操作ESspring.elasticsearch.jest.uris=http://192.168.1.5:9200 3），使用jest客户端操作ES 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.bjq.elactic;import com.bjq.elactic.bean.Article;import io.searchbox.client.JestClient;import io.searchbox.core.Index;import io.searchbox.core.Search;import io.searchbox.core.SearchResult;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@SpringBootTestclass SpringbootElactic03ApplicationTests { @Autowired JestClient jestClient; @Test public void contextLoads() { //1,给Es中索引（保存）一个文档 Article article = new Article(); article.setId(1); article.setTitle(&quot;天才在左&quot;); article.setAuthor(&quot;高明&quot;); article.setContent(&quot;这世界不对&quot;); //构建一个索引功能 Index index = new Index.Builder(article).index(&quot;bjq&quot;).type(&quot;news&quot;).build(); try { //执行 jestClient.execute(index); } catch (IOException e) { e.printStackTrace(); } } //测试搜索 @Test public void search(){ //构建查询表达式 String json = &quot;{\\n&quot; + &quot; \\&quot;query\\&quot; : {\\n&quot; + &quot; \\&quot;match\\&quot; : {\\n&quot; + &quot; \\&quot;content\\&quot; : \\&quot;hello\\&quot;\\n&quot; + &quot; }\\n&quot; + &quot; }\\n&quot; + &quot;}&quot;; Search search = new Search.Builder(json).addIndex(&quot;bjq&quot;).addType(&quot;news&quot;).build(); try { SearchResult result = jestClient.execute(search); System.out.println(result.getJsonString()); } catch (IOException e) { e.printStackTrace(); } }} 查看结果: ②： SpringData ElasticSearch【ES版本有可能不合适】这里会有一个大问题!!!!! 测试的时候我用的是Springboot的2.1.9版本 步骤: 1，开启xml配置文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 2，修改全局配置文件内容 123456#访问ES的集群的名称spring.data.elasticsearch.cluster-name=elasticsearch#ES节点的访问地址及端口spring.data.elasticsearch.cluster-nodes=192.168.43.78:9301#这个就不多说了server.port=8010 3，编写一个实体类: **@Document(indexName = “bjq”,type = “book”)**：表示在那个索引名字和那个类型下 indexName： 代表索引名称; type：代表索引类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bjq.elactic.bean;import org.springframework.data.elasticsearch.annotations.Document;@Document(indexName = &quot;bjq&quot;,type = &quot;book&quot;)public class Book { private Integer id; private String bookName; private String author; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return &quot;Book{&quot; + &quot;id=&quot; + id + &quot;, bookName='&quot; + bookName + '\\'' + &quot;, author='&quot; + author + '\\'' + '}'; }} 4，编写一个接口来继承 ElasticsearchRepository 来操作ES； 代码： 12345678package com.bjq.elactic.repotiory;import com.bjq.elactic.bean.Book;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;import org.springframework.stereotype.Component;public interface BookRepository extends ElasticsearchRepository&lt;Book,Long&gt; {} 5，测试: 代码: 把BookRepository注入进来，然后使用index（索引/保存）一个book对象 123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootElactic03ApplicationTests { @Autowired JestClient jestClient; @Autowired BookRepository bookRepository; Book book; @Test public void test02() { book= new Book(); bookRepository.index(book); }} 点击运行test02方法然后下面是个大问题; 报错信息; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960NoNodeAvailableException[None of the configured nodes are available: [{#transport#-1}{chbS1OylTHSCoZlPhglyTw}{127.0.0.1}{127.0.0.1:9300}]] at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodesAreAvailable(TransportClientNodesService.java:352) at org.elasticsearch.client.transport.TransportClientNodesService.execute(TransportClientNodesService.java:248) at org.elasticsearch.client.transport.TransportProxyClient.execute(TransportProxyClient.java:60) at org.elasticsearch.client.transport.TransportClient.doExecute(TransportClient.java:388) at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:403) at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:391) at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:46) at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.index(ElasticsearchTemplate.java:587) at org.springframework.data.elasticsearch.repository.support.AbstractElasticsearchRepository.save(AbstractElasticsearchRepository.java:176) at org.springframework.data.elasticsearch.repository.support.AbstractElasticsearchRepository.index(AbstractElasticsearchRepository.java:200) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments.invoke(RepositoryComposition.java:371) at org.springframework.data.repository.core.support.RepositoryComposition.invoke(RepositoryComposition.java:204) at org.springframework.data.repository.core.support.RepositoryFactorySupport$ImplementationMethodExecutionInterceptor.invoke(RepositoryFactorySupport.java:657) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:621) at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:605) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) at com.sun.proxy.$Proxy73.index(Unknown Source) at com.bjq.elactic.SpringbootElactic03ApplicationTests.test02(SpringbootElactic03ApplicationTests.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675) at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:125) at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:132) at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:124) at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:74) at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:104) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:62) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:43) at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:35) at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:202) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:198) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) at java.util.ArrayList.forEach(ArrayList.java:1257)//后面省略.... 网上查了很多资料，有的说在config文件夹里面改什么的，这里是docker方式启动的不是下载在虚拟机里面的，所以弄了大半天的时间研究，后面我实在是新建了一个工程换了springboot版本才得以解决，以免下次在遇到在此记录一下 我们把2.1.9换成1.5.12版本的 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;1.5.21.RELEASE&lt;/version&gt;&lt;/parent&gt; 然后点击testo2方法运行；又出现如下错误 123456789101112131415org.elasticsearch.transport.ConnectTransportException: [][192.168.43.78:9300] connect_timeout[30s] at org.elasticsearch.transport.netty.NettyTransport.connectToChannelsLight(NettyTransport.java:967) ~[elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.transport.netty.NettyTransport.connectToNode(NettyTransport.java:933) ~[elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.transport.netty.NettyTransport.connectToNodeLight(NettyTransport.java:906) ~[elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.transport.TransportService.connectToNodeLight(TransportService.java:267) ~[elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.client.transport.TransportClientNodesService$SimpleNodeSampler.doSample(TransportClientNodesService.java:390) ~[elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.client.transport.TransportClientNodesService$NodeSampler.sample(TransportClientNodesService.java:336) [elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.client.transport.TransportClientNodesService.addTransportAddresses(TransportClientNodesService.java:187) [elasticsearch-2.4.6.jar:2.4.6] at org.elasticsearch.client.transport.TransportClient.addTransportAddress(TransportClient.java:243) [elasticsearch-2.4.6.jar:2.4.6] //很多省略 at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.21.RELEASE.jar:1.5.21.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.21.RELEASE.jar:1.5.21.RELEASE] at com.bjq.elactic.SpringbootElactic03Application.main(SpringbootElactic03Application.java:10) [classes/:na]Caused by: java.net.ConnectException: Connection refused: no further information: /192.168.43.78:9300 //很多省略 这里的原因是因为我们换了springboot的1.5.12版本导入的elasticsearch包的版本是2.4.6版本的我们docker使用的版本是5.6.9所以会出现这个错误 解决方法: 升级springboot版本; 安装对应的ES版本 升级springboot就算了吧，这里我又去下载了2.4.6版本的ES 步骤: 在 docker hub里面搜索elasticsearch的2.4.6版本 以docker的方式拉取 拉取完成后，运行 1docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9201:9200 -p 9301:9300 --name ES02 5e9d896dc62c 查看: 浏览器查看： 然后我们再来运行 后面使用_search可以看到我们bjq和book下所有的内容 两种用法参考资料： https://github.com/spring-projects/spring-data-elasticsearch 尤其得注意 12NoNodeAvailableException[None of the configured nodes are available: [{#transport#-1}{chbS1OylTHSCoZlPhglyTw}{127.0.0.1}{127.0.0.1:9300}]] 这个大问题！！！！差不多花了一天的时间,新手刚接触elasticsearch","link":"/2019/10/21/elasticsearch%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"使用JasperReport框架生成PDF报表","text":"为啥需要PDF打印报表？在企业级应用开发中，报表的方式有很多种除了之前说过的Excel报表，PDF也有着同样重要的广泛的使用场景。 常见PDF报表的制作方式1，iText PDF：是一个著名的开放项目，用于生成PDF文档德一个类库可以生成PDF，也可以从HTML转换成PDF，以及多种语言的书写支持，最新的产品发布可以将PDF转换为图像; 这是官网地址：https://itextpdf.com/en 2，Openoffice：Apache OpenOffice是一款先进的开源 办公软件套件，它包含文本文档、电子表格、演示文稿、绘图、数据库等。 它能够支持许多语言并且在所有普通计算机上工作。它将你所有的数据以国际开放标准格式存储下来。 这是官网的说明：https://www.openoffice.org/zh-cn/why/ 3，Jasper Report：也是接下来要使用的，个人理解呢虽说是一个制作PDF的生成方式，其实也就是一个工具而已。 优点：JasperReport是一个强大、灵活的报表生成工具，能够展示丰富的页面内容，并将之转换成PDF，HTML，或者XML格式。该库完全由Java写成，可以用于在各种Java应用程序，包括J2EE，Web应用程序中生成动态内容等等还有很多就不一一说明了 这是官网介绍地址：https://community.jaspersoft.com/documentation/tibco-jasperreports-io-user-guide/v75-v750-v12/introduction Jaspersoft Studio声明周期开始之前先说明一下这个声明周期的问题，一般通过Jaspersoft生成PDF报表一共要经历三个阶段，我们称之为Jaspersoft的声明周期，如下图所示： 三个阶段分别为： 设计(Design)**：也就是创建一些模板，包括布局与样式，以及执行计算的复杂公式，可选从数据源数据的查询语句**，以及其他的一些信息，设计完成后，将模板保存为JRXML文件，其实就是一个xml文件。 执行(Execution)**：也就是把JRXML文件编译成为可执行的二进制文件（即.Jasper文件）**结合数据进行，填充报表数据 输出(Export)**：数据填充完后，可以指定输出多种形式的报表。也就是查看** JasperReport原理简述 1，JRXML：报表填充模板，本质是一个XML JasperReport已经封装了一个dtd，只要按照规定的格式写这个xml文件，那么jasperReport就可以将其解析最终生成报表，但是jasperReport所解析的不是我们常见的.xml文件，而是.jrxml文件，其实跟xml是一样的，只是后缀不一样。 2，Jasper：由JRXML模板编译生成的二进制文件，用于代码填充数据。 解析完成后jasperReport就开始编译.jrxml文件，将其编译成.jasper文件，因为jasperReport只能对.jasper文件进行填充数据和转换，这操作和编译java文件成为class文件是一样的。 3，Jrpring:当用数据填充完Jasper后生成的文件，用于输出报表。 这一步是核心步骤，会根据你在xml里面写好的查询语句来查询指定是数据，也可以控制在后台编写查询语句，参数，数据库。在报表填充完后，会再生成一个.jrpring格式的文件（读取jasper文件进行填充，然后生成一个jrprint文件） 4，Exporter：决定要输的报表为何种格式，报表输出的管理类。 5，Jasperreport可以输出多种格式的报表文件，常见的有Html，PDF，xls等等。 上面都是一些理论知识： 下面可以看下代码如何实现： 导入Maven相关依赖： jasperreports我用6.5.0会有一点莫名其妙的错误所改成了6.5.1 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.jasperreports&lt;/groupId&gt; &lt;artifactId&gt;jasperreports&lt;/artifactId&gt; &lt;version&gt;6.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.olap4j&lt;/groupId&gt; &lt;artifactId&gt;olap4j&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itext&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 接下来创建一个测试的程序： 安装先运行createJasper其次是运行createJrprint最后运行showPdf createJasper方法的作用是：将PDF模板编译为Jasper文件 （注意：这一步前提是你要准备一个.jrxml文件）在下面准备了一个复制保存为.jrxml文件即可； createJrprint方法的作用是：将Jasper文件和数据进行填充，获取Jrprint 最后一步运行showPdf即可进行预览 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.jr;import net.sf.jasperreports.engine.JREmptyDataSource;import net.sf.jasperreports.engine.JasperCompileManager;import net.sf.jasperreports.engine.JasperFillManager;import net.sf.jasperreports.view.JasperViewer;import java.util.HashMap;public class JrDemo { public static void main(String[] args) { showPdf(); } //1.将pdf模板编译为Jasper文件 public static void createJasper(){ try{ String path = &quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\09章节\\\\test01.jrxml&quot;; JasperCompileManager.compileReportToFile(path); }catch(Exception e){ e.printStackTrace(); } } //2.将Jasper文件和数据进行填充，获取Jrprint public static void createJrprint(){ try{ String path = &quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\09章节\\\\test01.jasper&quot;; //通过空参数和空数据源进行填充 JasperFillManager.fillReportToFile(path,new HashMap(),new JREmptyDataSource()); }catch(Exception e){ e.printStackTrace(); } } //3.预览 public static void showPdf(){ try{ String path = &quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\09章节\\\\test01.jrprint&quot;; JasperViewer.viewReport(path,false); }catch(Exception e){ e.printStackTrace(); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Created with Jaspersoft Studio version 6.5.0.final using JasperReports Library version 6.5.0 --&gt;&lt;jasperReport xmlns=&quot;http://jasperreports.sourceforge.net/jasperreports&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd&quot; name=&quot;test01&quot; pageWidth=&quot;595&quot; pageHeight=&quot;842&quot; columnWidth=&quot;555&quot; leftMargin=&quot;20&quot; rightMargin=&quot;20&quot; topMargin=&quot;20&quot; bottomMargin=&quot;20&quot; uuid=&quot;b7211d1c-a575-48f1-b253-9c63f5f41307&quot;&gt; &lt;property name=&quot;com.jaspersoft.studio.data.defaultdataadapter&quot; value=&quot;One Empty Record&quot;/&gt; &lt;queryString&gt; &lt;![CDATA[]]&gt; &lt;/queryString&gt; &lt;background&gt; &lt;band splitType=&quot;Stretch&quot;/&gt; &lt;/background&gt; &lt;pageHeader&gt; &lt;band height=&quot;96&quot; splitType=&quot;Stretch&quot;&gt; &lt;image&gt; &lt;reportElement x=&quot;-20&quot; y=&quot;-20&quot; width=&quot;180&quot; height=&quot;50&quot; uuid=&quot;93b99d68-82d6-4d23-a6f8-6594b9c1af3e&quot;/&gt; &lt;imageExpression&gt;&lt;![CDATA[&quot;http://www.itcast.cn/2018czgw/images/logo.png&quot;]]&gt;&lt;/imageExpression&gt; &lt;/image&gt; &lt;line&gt; &lt;reportElement x=&quot;-20&quot; y=&quot;30&quot; width=&quot;591&quot; height=&quot;5&quot; uuid=&quot;69ffb590-4919-481e-922e-577ae367e59e&quot;/&gt; &lt;/line&gt; &lt;/band&gt; &lt;/pageHeader&gt; &lt;detail&gt; &lt;band height=&quot;80&quot; splitType=&quot;Stretch&quot;&gt; &lt;staticText&gt; &lt;reportElement x=&quot;230&quot; y=&quot;50&quot; width=&quot;100&quot; height=&quot;30&quot; uuid=&quot;104d722d-99b1-44f5-b3fb-582f78411ab5&quot;/&gt; &lt;textElement&gt; &lt;font fontName=&quot;华文宋体&quot;/&gt; &lt;/textElement&gt; &lt;text&gt;&lt;![CDATA[Jaspersoft好强大]]&gt;&lt;/text&gt; &lt;/staticText&gt; &lt;/band&gt; &lt;/detail&gt; &lt;pageFooter&gt; &lt;band height=&quot;75&quot; splitType=&quot;Stretch&quot;&gt; &lt;staticText&gt; &lt;reportElement x=&quot;230&quot; y=&quot;20&quot; width=&quot;100&quot; height=&quot;30&quot; uuid=&quot;6863d3c6-774e-4f7c-adda-5f1bc6148c78&quot;/&gt; &lt;textElement&gt; &lt;font fontName=&quot;华文宋体&quot;/&gt; &lt;/textElement&gt; &lt;text&gt;&lt;![CDATA[传智播客出品]]&gt;&lt;/text&gt; &lt;/staticText&gt; &lt;/band&gt; &lt;/pageFooter&gt;&lt;/jasperReport&gt; 预览成功会弹出一个窗口 如下图所示： 这样相当于一个静态的PDF页面 可能你会问，这样不麻烦吗，每次还得去准备一个.jrxml文件模板，还得生成Jasper一系列等等 反正我是觉得很麻烦，解决的方法有很多：我们可以使用模板工具Jaspersoft Studio来 制作模板，构造数据，填充数据，以及预览 Jaspersoft Studio是什么？简单来说呢，就是一个可视化的报表设计工具，使用该软件可以方便地对报表进行可视化的设计，设计结果为格式.jrxml的XML文件，并且可以把.jrxml文件编译成.jasper格式文件方便JasperReport报表引擎解析，显示(也就是预览)。 下载Jaspersoft Studio下载地址：https://community.jaspersoft.com/project/jaspersoft-studio 首先你可能需要注册一个账户才能进行下载，下载页面有一个企业版和社区版，选择社区版就可以了 Jaspersoft Studio介绍如果用过eclipse或者**Myeclipse的人会发现Jaspersoft Studio**的界面有点类似，其实这个软件是基于Eclipse开发的一个报表开发工具，官网上也有说明，目前最新版本是：6.11.0 基本使用1，打开Jaspersoft Studio，新建一个project, 步骤： File -&gt; New -&gt; Project-&gt; JasperReports Project起一个项目名称即可比如我的(TestReports) 2，新建一个Jasper Report模板，找到刚才新建的Project (我这里新建的是TestReports),步骤：项目右键 -&gt; New -&gt; Jasper Report 3，选择 Blank A4 (A4纸大小的模板)后面也可以自己尝试选择其他的模板，然后 Next 命名为test01.jrxml使用其他名字也可以 创建完成后就是这个样子的: Title(标题)：只在整个报表的第一页的最上端显示。只在第一页显示，其他页面均不显示。 Page Header(页头)：在整个报表中每一页都会显示。在第一页中，出现的位置在 Title Band的下面。在除了第一页的其他页面中Page Header 的内容均在页面的最上端显示。 Page Footer(页脚)：在整个报表中每一页都会显示。显示在页面的最下端。一般用来显示页码。 Detail 1(详细)：报表内容，每一页都会显示。 Column Header(列头)： Detail中打印的是一张表的话，这Column Header就是表中列的列头。 Column Footer(列脚)： Detail中打印的是一张表的话，这Column Footer就是表中列的列脚。 Summary(统计)：表格的合计段，出现在整个报表的最后一页中，在Detail 1 Band后面。主要是用来做报表的合计显示。 我们可以添加点东西比如：文字，图片； 我们先把其他用不到的Bead删掉只保留Page Header和Detail 1以及Page Footer在Palette面板中托入Static Text控件双击写上几个文字，托入Image控件，如下图所示： 再托入控件，最后设计是这样子的： 编译执行右键单机模板文件 -&gt; compile Report 对模板进行编译，生成.jasper文件 整合工程新建一个SpringBoot工程或者一个Maven工作，导入相关依赖 这里以Maven项目为例 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.jasperreports&lt;/groupId&gt; &lt;artifactId&gt;jasperreports&lt;/artifactId&gt; &lt;version&gt;6.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.olap4j&lt;/groupId&gt; &lt;artifactId&gt;olap4j&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itext&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置文件application.yml 12345678910server: port: 8082spring: application: name: jasper-springboot #指定服务名 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/xxx?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false username: root password: root 创建一个启动类 123456789101112131415package cn.itcast;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = &quot;cn.itcast&quot;)public class JasperApplication { /** * 启动方法 */ public static void main(String[] args) { SpringApplication.run(JasperApplication.class,args); }} 导入在Jaspersoft Studio生成的后缀为.jasper文件（比如我之间生成的test.jasper文件）把这个文件复制到resources–&gt;templates文件夹下，如下图所示 然后编写一个测试用的Controller代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.itcast.controller;import net.sf.jasperreports.engine.*;import org.springframework.core.io.Resource;import org.springframework.core.io.ClassPathResource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.util.HashMap;@RestControllerpublic class JasperController { @GetMapping(&quot;/testJasper&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws IOException { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/test.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { /** * fis: jasper 文件输入流 * new HashMap ：向模板中输入的参数 * JasperDataSource：数据源（和数据库数据源不同） * 填充模板的数据来源（connection，javaBean，Map） * 填充空数据来源：JREmptyDataSource */ JasperPrint print = JasperFillManager.fillReport(fis, new HashMap&lt;&gt;(),new JREmptyDataSource()); //3.将JasperPrint已PDF的形式输出 JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } }} 然后浏览器访问地址：http://localhost:8082/testJasper 最后的结果是这个样子的 注意：如果你没有处理补丁的话，中文字是显示不出来的，能看到的只有图像和英文字母，这其实是一个经典问题 解决的方式： 我们先在Jaspersoft Studio把Static Text的控件样式改变一下把字体样式改成华文宋体 然后执行compile Report编译然后再复制.jasper文件到ide中。接着我们还需要相应的处理 这个三个文件夹的代码也是从网上找来的；这里需要说明的是这里只提供了对华文宋体的处理，如果你是其他的字体样式有可能也是不会生效的 下载下来放到resources这个目录下 下载链接：https://pan.baidu.com/s/18dJjjKLEuerjVCtA1_hIFw提取码：0fjx 再重新启动一次即可解决，如果重启报错的话，可以试着重启一下ide，因为我在测试过程中老是报错找不到文件什么的，重启Ide即可解决。 charts图形报表：1，创建一个模板取名为testCharts.jrxml，删除不需要的band，保留title和summary 2，创建Fields： 注意： 这里Description就不用写什么直接就是空白就好了 不然很有可能会出现错误 3，创建Chart: 在Plette面板中托入Chart控件放入到band中 选择需要的图标类型：这里选择Pie Chart图形,然后点击Next 设置参数： 注意的是：点击后面按钮…添加内容 Key： 圆饼图的内容是什么，也就是下面的 First， Second…的内容 Value：这个圆饼图的比例依据，根据 Value 属性来显示每个 Key 占的比例 Label：显示标签 然后点击Finish 最后编译testCharts.jrxml复制testCharts.jasper到IDE中templates目录下 新建一个实体类： 123456789101112131415161718192021222324252627package cn.itcast.domain;public class UserCount { private String company; private Long count; public UserCount(String company, Long count) { this.company = company; this.count = count; } public String getCompany() { return company; } public void setCompany(String company) { this.company = company; } public Long getCount() { return count; } public void setCount(Long count) { this.count = count; }} 测试程序代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.itcast.controller;import cn.itcast.domain.User;import cn.itcast.domain.UserCount;import net.sf.jasperreports.engine.JRException;import net.sf.jasperreports.engine.JasperExportManager;import net.sf.jasperreports.engine.JasperFillManager;import net.sf.jasperreports.engine.JasperPrint;import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class JasperController6 { /** * charts图形报表 */ @GetMapping(&quot;/testJasper6&quot;) public void createPdf(HttpServletRequest request, HttpServletResponse response) throws Exception { //1.引入jasper文件 Resource resource = new ClassPathResource(&quot;templates/testCharts.jasper&quot;); FileInputStream fis = new FileInputStream(resource.getFile()); //2.创建JasperPrint,向jasper文件中填充数据 ServletOutputStream os = response.getOutputStream(); try { Map parameters = new HashMap&lt;&gt;(); //构建javaBean的数据源 //1.获取到对象的list集合 List&lt;UserCount&gt; userList = getUserCountList(); //2.通过list集合创建javaBean的数据源对象 JRBeanCollectionDataSource ds = new JRBeanCollectionDataSource(userList); JasperPrint print = JasperFillManager.fillReport(fis,parameters,ds); JasperExportManager.exportReportToPdfStream(print,os); } catch (JRException e) { e.printStackTrace(); }finally { os.flush(); } } public List&lt;UserCount&gt; getUserCountList() { List&lt;UserCount&gt; list = new ArrayList&lt;&gt;(); UserCount uc1 = new UserCount(&quot;云号科技&quot;,1000l); UserCount uc2 = new UserCount(&quot;谷歌&quot;,1000l); UserCount uc3 = new UserCount(&quot;baidu&quot;,1000l); list.add(uc1); list.add(uc2); list.add(uc3); return list; }} 浏览器访问：","link":"/2020/02/06/%E4%BD%BF%E7%94%A8JasperReport%E6%A1%86%E6%9E%B6%E7%94%9F%E6%88%90PDF%E6%8A%A5%E8%A1%A8/"},{"title":"初次使用rabbitmq","text":"Rabbitmq是什么？RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端函式库。 使用场景如果说在秒杀商品的时候，系统会提示我们稍等排队，不是说是页面直接是卡死的状态呈现给用户。 排队等消息的机制就使用了消息队列，放入消息队列一个一个的处理，不是在某个时间突然来了一大批的查询新增把数据库给搞坏了，所以RabbitMQ从本质上起到的作用就是流量削峰； 为什么使用了RabbitMQ市面上不止这一家MQ，比如说：ActiveMQ，ZeroMQ，等等…. JMS（Java Message Service）JAVA消息服务： –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 AMQP（Advanced Message Queuing Protocol） –高级消息队列协议，也是一个消息代理的规范，兼容JMS –RabbitMQ是AMQP的实现 RabbitMQ常见名词 Exchange （交换器） ： 用于接受、分配消息； Publisher（消息生产者）： 也是一个向交换器发布消息的客户端应用程序。 Queues （消息队列） ： 用于存储生产者的消息； Channel （信道） ： 消息推送使用的通道； RoutingKey（路由键）：用于把生成者的数据分配到交换器上； BindingKey（绑定键）：用于把交换器的消息绑定到队列上； 三种常用分发策略（总共有四种）根据消息的分发根据类型的不同分发策略有区别,目前总共四种类型： direct、fanout、topic、headers ,其中header不常用 Exchange 单播（点对点方式） 广播的方式(fanout)像子网广播，每台子网都从主机获得了一份复制的消息。fanout类型转发消息是最快的 topic交换器通过匹配分配消息，这些单词之间用点隔开。符号“#”和符号“”。”#”匹配0个到多个单词，“*”匹配一个单词 RabbitMQ环境搭建1，以**docker**的方式下载 2，启动RabbitMQ执行命令: 1docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 27764c8758a0 2.1，其中-p 15672:15672是RabbitMQ访问管理页面的端口号 2.2，然后在本地浏览器访问：http://192.168.43.78:15672/ 2.3，这个是主页面，如果是第一次会让你进行登陆，默认账号：guest，密码：guest登陆进来就可以看到这个页面 点击Exchanges按钮 找到这个Add a new exchange 接着你可以在上面看到创建的Exchanges交换器 接着点击Queuess按钮来添加我们的消息队列 上面可以看到创建的队列 如果要想这些队列工作的话我们得把他们进行关联绑定起来 我们点击我们自己创建的交换器 找到绑定关系 在绑定关系上面可以看到绑定成功 这里只示例了第一种点对点的分发策略，其他的策略添加相似 然后我们进行消息发布测试一下 发布成功 点击Queuess查看消息，点击bjq队列 找到Get Messages 点击**GetMessage(s)**框框里面就是发布的消息 Springboot整合使用RabbitMQ1，引入spring-boot-starter-amqp1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2，application.properties文件配置12345spring.rabbitmq.host=192.168.43.78 //服务器地址spring.rabbitmq.username=guest //RabbitMQ的账号spring.rabbitmq.password=guest //RabbitMQ的密码server.port=8010 //这个就不多说了 3，测试RabbitMQ3.1，相关类 RabbitAutoConfiguration ：自动配置类 ConnectionFactory：连接工厂; RabbitProperties：封装了RabbitMQ的配置； RabbitTemplate：给Rabbitmq发送和接受消息 AmqpAdmin：是RabbitMQ的系统管理功能组件 3.2，测试： 3.2.1单播（点对点方式） 123456789101112131415161718192021222324252627@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot02AmqpApplicationTests { //注入RabbitTemplate @Autowired RabbitTemplate rabbitTemplate; /** * 测试:单播（点对点） */ @Test public void contextLoads() { /** * message需要自己构造 */ //rabbitTemplate.send(exchage,routeKey,message); //Object默认被当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq //rabbitTemplate.convertAndSend(exchage,routeKey,Object); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第一个测试消息&quot;); map.put(&quot;data&quot;, Arrays.asList(&quot;HelloWorld&quot;,123,true)); //对象被默认序列化后发送出去 //连接exchange.direct交换器，使用bjq.news路由键,map是要发送的内容 rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;bjq.news&quot;,map); }} 3.2.2，在RabbitMQ管理页面查看（保证你的服务器地址是能连接上的） 在bjq.news消息队列里面查看 可以看到虽然是看到我们的数据了，但是是一串被java序列化的数据（默认的方式） 接着我们试着来接受数据 1234567//接受数据，如何将数据自动的转换为json格式 @Test public void receive(){ Object o = rabbitTemplate.receiveAndConvert(&quot;bjq.news&quot;); System.out.println(o.getClass()); System.out.println(o); } 再去管理页面刷新可以看到bjq.news队列里面的消息为0了 如何把数序列化成json格式再发出去？、在RabbitTemplate类里面有一个默认消息转换器类:SimpleMessageConverter这个类里面默认使用的是jdk的序列化机制 1private MessageConverter messageConverter = new SimpleMessageConverter(); 我们自己定义一个Jackson2JsonMessageConverter来替换它原本的MessageConverter 示例代码: 12345678910@Configurationpublic class MyAMQP { @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); }} 然后我们再试着发数据再查看,这次看到的数据就和之前看到的不一样了 我们把发出的数据传入一个对象Book类 123456789101112131415161718192021222324252627282930package com.bjq.amqp.bean;public class Book { private String bookName; private String author; public Book(String bookName, String author) { this.bookName = bookName; this.author = author; } public String getBookName() { return bookName; } public String getAuthor() { return author; } public void setBookName(String bookName) { this.bookName = bookName; } public void setAuthor(String author) { this.author = author; } } 然后我们再进行测试new一个对象（Book）传入书名和作者 12345678910111213141516@Test public void contextLoads() { /** * message需要自己构造 */ //rabbitTemplate.send(exchage,routeKey,message); //Object默认被当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq //rabbitTemplate.convertAndSend(exchange,routeKey,Object); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第一个测试消息&quot;); map.put(&quot;data&quot;, Arrays.asList(&quot;HelloWorld&quot;,123,true)); //对象被默认序列化后发送出去 //rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;bjq.news&quot;,map); //发布内容传入一个对象 rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;bjq.news&quot;,new Book(&quot;天才在左&quot;,&quot;高铭&quot;)); } 再去访问RabbitMQ管理页面 也是没有问题的 但是！在反序列化将数据取出的时候出错了 错误信息 12345678910111213141516171819202122232425262728293031323334353637383940org.springframework.amqp.support.converter.MessageConversionException: Failed to convert Message content at org.springframework.amqp.support.converter.AbstractJackson2MessageConverter.fromMessage(AbstractJackson2MessageConverter.java:218) at org.springframework.amqp.support.converter.AbstractJackson2MessageConverter.fromMessage(AbstractJackson2MessageConverter.java:180) at org.springframework.amqp.rabbit.core.RabbitTemplate.receiveAndConvert(RabbitTemplate.java:1215) at org.springframework.amqp.rabbit.core.RabbitTemplate.receiveAndConvert(RabbitTemplate.java:1201) at com.bjq.amqp.Springboot02AmqpApplicationTests.receive(Springboot02AmqpApplicationTests.java:47) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.bjq.amqp.bean.Book` (no Creators, like default construct, exist): cannot deserialize from Object value (no delegate- or property-based Creator) at [Source: (String)&quot;{&quot;bookName&quot;:&quot;天才在左&quot;,&quot;author&quot;:&quot;高铭&quot;}&quot;; line: 1, column: 2] at 后面很多省略.... 我查询了谷歌和百度,很多没遇到过这个问题，然后看到这篇 https://stackoverflow.com/questions/40240771/messageconversionexception-failed-to-convert-message-content 文章，我又回去看了我看的实体类，发现无参构造方法没写，写上之后，再测试。可以运行; 记一次自己不细心的错误; 然后还有广播的方式； 测试代码： 12345678 /** * 广播 */@Testpublic void RabbitmqFanout(){ rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,new Book(&quot;Spring第四版&quot;,&quot;张卫彬&quot;));} 以广播的方式给每个队列都发了消息；可以看到消息队列变成1了 如何监听消息队列里面的内容？这里需要用到两个注解: @RabbitListener：里面有一个Queuess属性，用来指定要监听哪一个消息队列 @EnableRabbit：用来开启基于注解的RabbitMQ模式 编写Service代码 123456789101112131415@Servicepublic class BookService { /** * @RabbitListener用来监听消息队列里面得内容 * @param book */ @RabbitListener(Queuess = &quot;bjq&quot;) public void listening(Book book) { System.out.println(&quot;收到消息&quot;+book); }} 主方法加上注解：@EnableRabbit 123@EnableRabbit //开启基于注解的RabbitMQ模式@SpringBootApplicationpublic class Springboot02AmqpApplication { 如果收到的消息是这样子的 在Book类里面添加toString方法即可 如果交换器和消息队列没有提前创建好，程序中应该怎么做?可以用到：AmqpAdmin这个类 AmqpAdmin：用来创建和删除Queues，Exchange，Binding 测试代码: 12345678910@AutowiredAmqpAdmin amqpAdmin;@Testpublic void createExchange(){ //new一个Direct的Exchange amqpAdmin.declareExchange(new DirectExchange(&quot;amqpbjq.news&quot;)); System.out.println(&quot;创建完成&quot;);} 不同类型的Exchange 查看管理页面 创建Queuess 测试代码: 12345678910111213@Autowired AmqpAdmin amqpAdmin; @Test public void createExchange() { //new一个Direct的Exchange //amqpAdmin.declareExchange(new DirectExchange(&quot;amqpbjq.news&quot;)); //创建Queues第一个参数是Queues的名字第二个是否持久化 amqpAdmin.declareQueue(new Queue(&quot;amqpbjq.queue&quot;,true)); System.out.println(&quot;创建完成&quot;); } 查看Queues: 给上面这两个创建绑定关系：Binding 测试代码: 123456789@Autowired AmqpAdmin amqpAdmin; @Test public void createExchange() { amqpAdmin.declareBinding(new Binding(&quot;amqpbjq.queue&quot;,Binding.DestinationType.QUEUE,&quot;amqpbjq.news&quot;,&quot;amqu.haha&quot;,null)); System.out.println(&quot;绑定完成&quot;); } 查看绑定关系: 自制视频 到此结束； 参考资料 万能的谷歌和百度 以及docker 以及不太聪明的脑子","link":"/2019/10/18/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8rabbitmq/"},{"title":"许学 学习FreeMarker","text":"前言:在这使用的比较流行的模板引擎：jsp后来学习了Thymeleaf，发现其实也是有需要一点语法的，到现在学习一下FreeMarker，其实这三者呢都是模板引擎，都有各自的优缺点，说白了就是各有各的好，可以根据实际情况来使用 What is Apache FreeMarker™?简单来说：就是一个模板引擎，一个Java库，根据模板和不断变化的数据生成文本输出(HTML，网页，电子邮件，配置文件，源代码等)，虽然FreeMarker也有编程能力，但大多数时候都是由java程序来准备要显示得数据。官网有更加详细的说明：https://freemarker.apache.org/index.html FreeMarker执行流程：上面是一个模板文件，下面是Java代码通过FreeMarker解析获取最后输出显示到页面，这种方式也成为MVC（模型视图控制器）,动态网页中特别流行，可以在web程序中使用，也可以用于非web应用程序环境中 FreeMarker使用场景：1，动态页面 基于模板配置和表达式生成页面文件，可以像jsp一样被客户端访问 2，页面静态化 对于系统中频繁使用数据库进行查询但是内容更新很小的应用，都可以用FreeMarker将网页静态化，这样就避免了大量的数据库访问请求，从而提高网站的性能 3，代码生成器 可以自动根据后台配置生成页面或者代码 freeMarker得特征和亮点：（官网也有详细的说明） 强大得模板语言：条件块，迭代，赋值，字符串和算术运算和格式，宏和函数（包括其他模板），默认转义（可选）等 多用途，轻量级：零依赖性，任何输出格式，可以从任何位置加载模板（可插拔），许多配置选项 国际化/本地化意识：区域设置敏感的数字和日期/时间格式，本地化的模板变体。 XML处理功能：将XML DOM放入数据模型并遍历它们，甚至进行声明式处理 通用的数据模型：Java对象通过可插拔适配器以变量树的形式暴露于模板，该适配器决定了模板如何看待它们。 FreeMarker基本使用：1，导入依赖：官网的jar包更新到了2.3.29 12345678910111213141516171819&lt;dependencies&gt; &lt;!--核心包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2，在src同级目录下新建一个文件夹templates然后新建一个模板文件template01.ftl：1欢迎您：${username},学习FreeMarker 3，新建一个测试类输出方式有两种：一种是输出到文件，一种输出到控制台，也能转换成为一个HTMl文件 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.freemarker.test;import freemarker.cache.FileTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import org.junit.Test;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * 第一个测试程序 */public class FreeMarkerTest01 { @Test public void test01() throws IOException, TemplateException { //1.创建FreeMarker的配置类 Configuration cfg = new Configuration(); //2.指定模板的加载路径,将其存入缓存中 //2.1指定文件的加载路径 FileTemplateLoader loader = new FileTemplateLoader(new File(&quot;templates&quot;)); cfg.setTemplateLoader(loader); //3.获取模板 Template template = cfg.getTemplate(&quot;template01.ftl&quot;); //4.构造数据模型 Map&lt;String,Object&gt; map = new HashMap(); map.put(&quot;username&quot;,&quot;小棋&quot;); //5.文件输出 //template.process(map,new FileWriter(new File(&quot;D:\\\\saas\\\\11-代码生成器原理分析及环境搭建\\\\代码\\\\a.txt&quot;))); //输出一个文件 template.process(map,new PrintWriter(System.out));//打印到控制台 }} 同样也可以导出为一个html文件 123456789101112131415161718192021@Test public void test02() throws Exception { String dir =&quot;D:\\\\src\\\\SpringBoot\\\\Saas\\\\codeutils\\\\templates&quot;; Configuration conf = new Configuration(); //加载模板文件(模板的路径) conf.setDirectoryForTemplateLoading(new File(dir)); // 加载模板 Template template = conf.getTemplate(&quot;/template01.ftl&quot;); // 定义数据 Map root = new HashMap(); root.put(&quot;world&quot;, &quot;Hello World&quot;); // 定义输出 Writer out = new FileWriter(dir + &quot;/freemarker.html&quot;); template.process(root, out); System.out.println(&quot;转换成功&quot;); out.flush(); out.close(); } A，字符串模板和之前以获取文件的方式是差不多的 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.freemarker.test;import freemarker.cache.FileTemplateLoader;import freemarker.cache.StringTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import org.junit.Test;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.util.HashMap;import java.util.Map;/** * 测试字符串模板 */public class FreeMarkerTest02 { @Test public void test() throws IOException, TemplateException { //1.创建FreeMarker的配置类 Configuration cfg = new Configuration(); //2.指定加载器 cfg.setTemplateLoader(new StringTemplateLoader()); //3.创建字符串模板 //i.字符串 String loader = &quot;欢迎：${username}学习&quot;; //i.通过字符串创建模板 Template template = new Template(&quot;name&quot;,new StringReader(loader),cfg); //4.构造数据模型 Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;username&quot;,&quot;张三&quot;); //5.处理模板 template.process(map,new PrintWriter(System.out)); }} 内置指令：if指令 可以使用if，elseif和else指令来条件判断是否越过模板的一个部分 使用方式： 在java代码传递值过来进行判断分别输出 1234567891011121314151617&lt;#if flag=1&gt; 传入数据=1 &lt;#elseif flag=2&gt; 传入数据=2 &lt;#else&gt; 传入数据=其他&lt;/#if&gt;&lt;#--也可以只有if没有elseif和else--&gt;&lt;#if x == 1&gt; 传入数据=1&lt;/#if&gt;&lt;#--也可以只有if没有elseif和else--&gt;&lt;#if x == 1&gt; 传入数据=1&lt;#else&gt; 传入数据=2&lt;/#if&gt; list指令：为weeks取一个别名，循环输出全部内容 123456List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;星期一&quot;);list.add(&quot;星期二&quot;);list.add(&quot;星期三&quot;);list.add(&quot;星期四&quot;);map.put(&quot;weeks&quot;,list); 123&lt;#list weeks as abc&gt; ${abc}&lt;/#list&gt; include指令你可以使用它们在你的模板中插入另外FreeMarker模板文件(由 *path* 参数指定)。 123&lt;#include path&gt; 或&lt;#include path options&gt; 使用方式： 新建一个模板然后直接复制他的名字即可 12&lt;#--模板包含--&gt;&lt;#include &quot;template02.ftl&quot;&gt; assign指令使用该指令你可以创建一个新的变量，或者替换一个已经存在的变量，注意的是：仅仅顶级变量可以被创建/替换也就是说你不能创建/替换 some_hash.subvar， 除了 some_hash)。 使用方式： 1234567&lt;#assign name=&quot;张三&quot;&gt;/0${name}或&lt;#assign name&gt; capture this&lt;/#assign&gt;${name} 内置函数： 1欢迎您：${'username'?substring(3)},学习FreeMarker 取子串 1欢迎您：${'username'?cap_first},学习FreeMarker &lt;#--首字母大写--&gt; 1欢迎您：${'username'?uncap_first},学习FreeMarker &lt;#--首字母小写--&gt; 以上指令参考官网指令：http://freemarker.foofun.cn/ref_builtins_string.html#ref_builtin_trim 数据库之元数据1，什么是数据元数据？元数据（MetData）就是用来描述数据的数据，举个例子：比如你的游戏图片，游戏名字，等等。。。这些叫做数据，而元数据是描述数据的数据称为元数据，比如你的游戏名字有多长，你的游戏图片有多大 2，数据库元数据的作用应用设计时候能够充分地利用数据元数据 深入理解了数据库的组织结构，再去理解数据访问相关框架的实现原理会比较容易。 3，如何获取元数据JDBC来处理数据库的接口主要有三个，即Connection，PreparedStatement和ResultSet这三个，而对于这三个接口，还可以获取不同类型的元数据，通过这些元数据类获得一些数据库的信息。下面将对这三种类型的元数据对象进行各自的介绍并通过使用MYSQL数据库进行案例说明； 1.1数据库元数据我们可以使用：java.sql下的（DatabaseMetaData）获取数据库的一些整体信息，比如数据库的产品名称，数据库的版本号，数据库的URL，是否支持事务等等。 API中一些常用的方法 getDatabaseProductName() 检索该数据库产品的名称。 getDatabaseProductName() 检索该数据库产品的名称 getUserName() 检索此数据库所知的用户名。 getURL() 检索此数据库管理系统的网址。 getDriverName() 检索该JDBC驱动程序的名称。 getDriverVersion() 检索该JDBC驱动程序的版本号为 String。 isReadOnly：查看数据库是否只允许读操作 supportsTransactions：查看数据库是否支持事务 1.2 案例：1，首先导入数据库的依赖包，这里使用的是mysql作为测试 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.7.12&lt;/version&gt; &lt;/dependency&gt; 2，获取数据库一些综合信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import freemarker.cache.StringTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import org.junit.Before;import org.junit.Test;import org.omg.CORBA.FREE_MEM;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Properties;/** * 测试元数据 */public class DataBaseMetaDataTest { Connection connection = null; @Before public void init() throws ClassNotFoundException, SQLException { String driver =&quot;com.mysql.jdbc.Driver&quot;; String url = &quot;jdbc:mysql://localhost:3306/ihrm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; Properties properties = new Properties(); properties.put(&quot;remarkReporting&quot;,&quot;true&quot;); properties.put(&quot;user&quot;,username); properties.put(&quot;password&quot;,password); //1,获取连接 Class.forName(driver); connection = DriverManager.getConnection(url, properties); } //获取数据库基本信息 @Test public void test01() throws SQLException, ClassNotFoundException { //2,获取元数据 DatabaseMetaData metaData = connection.getMetaData(); //3,获取数据库基本信息 System.out.println(metaData.getUserName()); System.out.println(metaData.supportsTransactions()); //查看数据库是否支持事务 System.out.println(metaData.getDatabaseProductName());//获取数据库的名称 //还有一些其他方法可以自行尝试 } 3，获取数据库列表 12345678910111213141516/** * 查询数据库列表名称 */ @Test public void test02() throws SQLException { //2,获取元数据 DatabaseMetaData metaData = connection.getMetaData(); //获取数据信息 ResultSet resultSet = metaData.getCatalogs(); while (resultSet.next()){ System.out.println(resultSet.getString(1)); } resultSet.close(); connection.close(); } 4，获取某数据库中的所有表信息 123456789101112131415161718192021//获取指定数据库表中的信息 @Test public void test03() throws SQLException { //2,获取元数据 DatabaseMetaData metaData = connection.getMetaData(); //获取库中表的名称 /** * String catalog, 代表当前操作的数据库 * String schemaPattern, 在mysql中可以为空，在Oracle中是需要填写上用户名的， * String tableNamePattern, 可以填空代表查询所有表,非空就是查询目标 * String tableNamePattern, 可以填空代表查询所有表,非空就是查询目标 * String types[] 查询 */ ResultSet resultSet = metaData.getTables(null, null,null, new String[]{&quot;TABLE&quot;}); while (resultSet.next()){ System.out.println(resultSet.getString(&quot;TABLE_NAME&quot;)); } } 5，获取指定表中的字段信息 12345678910111213141516171819202122//获取指定表中的字段信息 @Test public void test04() throws SQLException { //2,获取元数据 DatabaseMetaData metaData = connection.getMetaData(); //获取表的字段名 /** * 最后一个参数可以写成null表示查询所有的字段名， * String catalog, * String schemaPattern, * String tableNamePattern, 表示查询那个表的字段 * String columnNamePattern */ ResultSet res = metaData.getColumns(null, null, &quot;bs_user&quot;, null); while (res.next()){ System.out.println(res.getString(&quot;column_name&quot;)); } } 1.3 参数元数据参数元数据（ParameterMetaData）：是由PreparedStatement对象通过getParameterMetaData方法获取而来，主要是针对PreparedStatement对象和其预编译的SQL命令语句提供一些信息，ParameterMetaData能提供占位符参数的个数，获取指定位置占位符的SQL类型等等 API中一些常用的方法： getParameterCount() 检索中的参数数目 PreparedStatement对象，这个对象包含的信息 ParameterMetaData。 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142import org.junit.Before;import org.junit.Test;import java.sql.*;import java.util.Properties;public class PreparedMetaDataTest { Connection connection = null; @Before public void init() throws ClassNotFoundException, SQLException { String driver =&quot;com.mysql.jdbc.Driver&quot;; String url = &quot;jdbc:mysql://localhost:3306/ihrm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; Properties properties = new Properties(); properties.put(&quot;remarkReporting&quot;,&quot;true&quot;); properties.put(&quot;user&quot;,username); properties.put(&quot;password&quot;,password); //1,获取连接 Class.forName(driver); connection = DriverManager.getConnection(url, properties); } @Test public void test01() throws SQLException { String sql = &quot;select * from bs_user where id=?&quot;; PreparedStatement pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;1063705482939731968&quot;); //获取参数元数据 ParameterMetaData parameterMetaData = pstmt.getParameterMetaData(); int count = parameterMetaData.getParameterCount(); System.out.println(count); }} 1.4 结果集元数据结果集元数据（ResultSetMetaData）：是由ResultSet对象通过getMetaData方法获取而来，主要是针对由数据库执行的SQL脚本命令获取的结果集对象ResultSet中提供的一些信息，比如结果集中的列数、指定列的名称、指定列的SQL类型等等，可以说这个是对于框架来说非常重要的一个对象 API中常用方法： getColumnCount() 在这 ResultSet对象返回的列数。 getColumnType(int column) 检索指定列的SQL类型。 getColumnTypeName(int column) 检索指定的列的数据库特定类型名称。 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.junit.Before;import org.junit.Test;import java.sql.*;import java.util.Properties;/** * 测试结果集元数据(ResultSetMetaData) * 通过ResultSet获取 * 获取查询结果的信息 */public class ResultSetMetaDataTest { Connection connection = null; @Before public void init() throws ClassNotFoundException, SQLException { String driver =&quot;com.mysql.jdbc.Driver&quot;; String url = &quot;jdbc:mysql://localhost:3306/ihrm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; Properties properties = new Properties(); properties.put(&quot;remarkReporting&quot;,&quot;true&quot;); properties.put(&quot;user&quot;,username); properties.put(&quot;password&quot;,password); //1,获取连接 Class.forName(driver); connection = DriverManager.getConnection(url, properties); } @Test public void test() throws SQLException { String sql = &quot;select * from bs_user where id=?&quot;; PreparedStatement pstmt = connection.prepareStatement(sql); pstmt.setString(1, &quot;1063705482939731968&quot;); //执行sql语句 ResultSet rs = pstmt.executeQuery() ; //获取ResultSetMetaData对象 ResultSetMetaData metaData = rs.getMetaData(); //获取查询字段数量 int columnCount = metaData.getColumnCount() ; for (int i=1;i&lt;=columnCount;i++) { //获取表名称 String columnName = metaData.getColumnName(i); //获取java类型 String columnClassName = metaData.getColumnClassName(i); //获取sql类型 String columnTypeName = metaData.getColumnTypeName(i); System.out.println(columnName+&quot;---&quot;+columnClassName+&quot;---&quot;+columnTypeName); } System.out.println(columnCount); }}","link":"/2020/02/15/%E8%AE%B8%E5%AD%A6-%E5%AD%A6%E4%B9%A0FreeMarker/"}],"tags":[{"name":"认真生活，认真扯蛋","slug":"认真生活，认真扯蛋","link":"/tags/%E8%AE%A4%E7%9C%9F%E7%94%9F%E6%B4%BB%EF%BC%8C%E8%AE%A4%E7%9C%9F%E6%89%AF%E8%9B%8B/"},{"name":"学学","slug":"学学","link":"/tags/%E5%AD%A6%E5%AD%A6/"},{"name":"是不太友好的一天","slug":"是不太友好的一天","link":"/tags/%E6%98%AF%E4%B8%8D%E5%A4%AA%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%B8%80%E5%A4%A9/"},{"name":"做人潇洒一点","slug":"做人潇洒一点","link":"/tags/%E5%81%9A%E4%BA%BA%E6%BD%87%E6%B4%92%E4%B8%80%E7%82%B9/"},{"name":"保持好奇与学习","slug":"保持好奇与学习","link":"/tags/%E4%BF%9D%E6%8C%81%E5%A5%BD%E5%A5%87%E4%B8%8E%E5%AD%A6%E4%B9%A0/"},{"name":"王侯将相 宁有种乎!","slug":"王侯将相-宁有种乎","link":"/tags/%E7%8E%8B%E4%BE%AF%E5%B0%86%E7%9B%B8-%E5%AE%81%E6%9C%89%E7%A7%8D%E4%B9%8E/"}],"categories":[{"name":"瞎折腾","slug":"瞎折腾","link":"/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"CentOS Linux","slug":"CentOS-Linux","link":"/categories/CentOS-Linux/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"Servlet","slug":"Servlet","link":"/categories/Servlet/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Shiro","slug":"Shiro","link":"/categories/Shiro/"},{"name":"JDK","slug":"JDK","link":"/categories/JDK/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"Fiddler","slug":"Fiddler","link":"/categories/Fiddler/"},{"name":"七牛云","slug":"七牛云","link":"/categories/%E4%B8%83%E7%89%9B%E4%BA%91/"},{"name":"集合类","slug":"集合类","link":"/categories/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"JDBC","slug":"JDBC","link":"/categories/JDBC/"},{"name":"POI","slug":"POI","link":"/categories/POI/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"JasperReport","slug":"JasperReport","link":"/categories/JasperReport/"},{"name":"FreeMarker模板","slug":"FreeMarker模板","link":"/categories/FreeMarker%E6%A8%A1%E6%9D%BF/"}]}